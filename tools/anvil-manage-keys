#!/usr/bin/perl
# 
# This removes a bad key from a 
# 
# This program is setuid 'admin' and calls a (new) peer to read its host name and system UUID. It takes the 
# target's password in via a file.
# 
# Exit codes;
# 0 = Normal exit.
# 1 = No database connection.
# 2 = Job not found.
# 3 = No offending keys found.
# 
# TODO: Record the keys we remove, then check for the same keys on any other machine we know about. If any 
#       are found on those machines, create a job for that host to remove the same.
#       Also, look in the 'ip_addresses' table for any matching keys and delete them.
# 

use strict;
use warnings;
use Anvil::Tools;
use Text::Diff;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# Turn off buffering so that the pinwheel will display while waiting for the SSH call(s) to complete.
$| = 1;

my $anvil = Anvil::Tools->new();

# Read switches (target ([user@]host[:port]) and the file with the target's password. If the password is 
# passed directly, it will be used. Otherwise, the password will be read from the database.
$anvil->Get->switches({list => [
	"confirm", 
	"job-uuid", 
	], man => $THIS_FILE});
$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => $anvil->data->{switches}});
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "log_0115", variables => { program => $THIS_FILE }});

$anvil->Database->connect();
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, secure => 0, key => "log_0132"});
if (not $anvil->data->{sys}{database}{connections})
{
	# No databases, update the job, sleep for a bit and then exit. The daemon will pick it up and try 
	# again after we exit.
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0077"});
	sleep 10;
	$anvil->nice_exit({exit_code => 1});
}

# Pick up the job details
load_job_data($anvil);

# Process the bad keys
process_key($anvil);

# Done.
update_progress($anvil, 100, "job_0051");
$anvil->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

sub process_key
{
	my ($anvil) = @_;
	
	# Delete the key now.
	process_file($anvil, "/root/.ssh/known_hosts");
	
	# If we're root, look through other users also
	if (($< == 0) or ($> == 0))
	{
		# Walk through any other users.
		my $directory = "/home";
		local(*DIRECTORY);
		opendir(DIRECTORY, $directory);
		while(my $file = readdir(DIRECTORY))
		{
			next if $file eq ".";
			next if $file eq "..";
			my $full_path = $directory."/".$file;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
				file      => $file,
				full_path => $full_path,
			}});
			
			# If we're looking at a directory, scan it. Otherwise, see if it's an executable and that it
			# starts with 'scan-*'.
			if (-d $full_path)
			{
				# Check for a known_hosts file.
				my $known_hosts = $full_path."/.ssh/known_hosts";
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { known_hosts => $known_hosts }});
				if (-e $known_hosts)
				{
					process_file($anvil, $known_hosts);
				}
			}
		}
		closedir(DIRECTORY);
	}
	
	# Delete old state_uuids now.
	my $query = "
SELECT 
    state_uuid, 
    state_name, 
    state_note 
FROM 
    states 
WHERE 
    state_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)." 
AND 
    state_name LIKE 'host_key_changed::%'
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	# States aren't sync'ed, so we may need to check both/all DBs to find our data.
	foreach my $uuid (keys %{$anvil->data->{cache}{database_handle}})
	{
		my $results = $anvil->Database->query({uuid => $uuid, query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			results => $results, 
			count   => $count, 
		}});
		if ($count)
		{
			foreach my $row (@{$results})
			{
				my $state_uuid = $row->[0];
				my $state_name = $row->[1];
				my $state_note = $row->[2];
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					's2:state_uuid' => $state_uuid, 
					's3:state_name' => $state_name, 
					's4:state_note' => $state_note, 
				}});
				
				# Does this state match the one we're clearing up?
				my $host = ($state_name =~ /host_key_changed::(.*)$/)[0];
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { host => $host }});
				
				foreach my $known_hosts (sort {$a cmp $b} keys %{$anvil->{ssh_keys}})
				{
					if (exists $anvil->{ssh_keys}{$known_hosts}{host}{$host})
					{
						foreach my $algo (sort {$a cmp $b} keys %{$anvil->{ssh_keys}{$known_hosts}{host}{$host}})
						{
							my $this_key = $anvil->{ssh_keys}{$known_hosts}{host}{$host}{$algo}{key};
							my $bad_key  = $anvil->data->{bad_key};
							if ($this_key eq $bad_key)
							{
								# Delete this key.
								$anvil->data->{job}{progress} += 5;
								update_progress($anvil, $anvil->data->{job}{progress}, "job_0004,!!state_uuid!".$state_uuid."!!,!!host!".$host."!!,!!db_uuid!".$uuid."!!");
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0049", variables => {
									state_uuid => $state_uuid, 
									db_uuid    => $uuid,
									host       => $host,
								}});
								delete_state($anvil, $state_uuid);
							}
						}
					}
				}
			}
		}
	}
	
	return(0);
}

# Look through the file for bad keys.
sub process_file
{
	my ($anvil, $file) = @_;
	my $bad_key        = $anvil->data->{bad_key};
	my $target         = $anvil->{ssh_key}{$bad_key}{host};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		's1:file'    => $file,
		's2:target'  => $target, 
		's3:bad_key' => $bad_key, 
	}});
	
	$anvil->data->{job}{progress} += 5;
	update_progress($anvil, $anvil->data->{job}{progress}, "job_0049,!!file!".$file."!!,!!target!".$target."!!");
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0049", variables => {
		file   => $file, 
		target => $target, 
	}});
	
	# Read in the file, if it exists.
	if (not -e $file)
	{
		# File doesn't actually exist, wtf?
		$anvil->data->{job}{progress} += 10;
		update_progress($anvil, $anvil->data->{job}{progress}, "job_0050,!!file!".$file."!!");
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0050", variables => { file => $file }});
		
		return(1); 
	}
	
	# Read in the file
	my ($old_body) = $anvil->Storage->read_file({file => $file});
	if ($old_body eq "!!error!!")
	{
		# Failed to read the file
		$anvil->data->{job}{progress} += 5;
		update_progress($anvil, $anvil->data->{job}{progress}, "job_0052,!!file!".$file."!!");
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0052", variables => { file => $file }});
		
		return(1);
	}
	
	# Find our key(s)
	my $line_number = 0;
	my $new_body    = "";
	foreach my $line (split/\n/, $old_body)
	{
		$line_number++;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { line => $line_number.":".$line }});
		
		if ($line =~ /\Q$bad_key\E/)
		{
			# Skip this key
			update_progress($anvil, $anvil->data->{job}{progress}, "job_0054,!!line!".$line_number."!!");
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0054", variables => { line => $line_number }});
		}
		else
		{
			$new_body .= $line."\n";
		}
	}
	
	my $difference = diff \$old_body, \$new_body, { STYLE => 'Unified' };
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 1, key => "log_0003", variables => { 
		file       => $file, 
		difference => $difference,
	}});
	
	if ($difference)
	{
		# Write the file out.
		$anvil->data->{job}{progress} += 5;
		update_progress($anvil, $anvil->data->{job}{progress}, "job_0055,!!file!".$file."!!");
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0055", variables => { file => $file }});
		
		# Get the owning user and group.
		my ($owning_uid, $owning_gid) = (stat($file))[4,5];
		my $owning_user               = getpwuid($owning_uid);
		my $owning_group              = getpwuid($owning_gid);
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			owning_uid   => $owning_uid, 
			owning_gid   => $owning_gid, 
			owning_user  => $owning_user, 
			owning_group => $owning_group,
		}});
		
		my $error = $anvil->Storage->write_file({
			body      => $new_body,
			debug     => 3,
			file      => $file,
			overwrite => 1,
			user      => $owning_user, 
			group     => $owning_group
		});
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, secure => 0, list => { error => $error }});
		if ($error)
		{
			$anvil->data->{job}{progress} += 5;
			update_progress($anvil, $anvil->data->{job}{progress}, "job_0059,!!file!".$file."!!");
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0059", variables => { file => $file }});
		}
		else
		{
			# Success!
			$anvil->data->{job}{progress} += 5;
			update_progress($anvil, $anvil->data->{job}{progress}, "job_0060,!!file!".$file."!!");
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0060", variables => { file => $file }});
		}
	}
	
	return(0);
}

# Load the job data or exit
sub load_job_data
{
	my ($anvil) = @_;
	
	# Create a job for all hosts.
	$anvil->Database->get_hosts({debug => 3});
	
	# Before I start. read in my known_hosts file so I can translate file/lines. 
	my $known_hosts    = "";
	my $home_directory = $anvil->Get->users_home({debug => 3});
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { home_directory => $home_directory }});
	if ($home_directory)
	{
		$known_hosts = $home_directory."/.ssh/known_hosts";
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { known_hosts => $known_hosts }});
		
		if (-f $known_hosts)
		{
			my ($old_body) = $anvil->Storage->read_file({file => $known_hosts});
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { old_body => $old_body }});
			
			my $line_number = 0;
			foreach my $line (split/\n/, $old_body)
			{
				$line_number++;
				$line = $anvil->Words->clean_spaces({string => $line});
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { line => $line_number.":".$line }});
				
				$line =~ s/#.*$//;
				next if not $line;
				
				my ($host, $algo, $key) = ($line =~ /^(.*?)\s+(.*?)\s+(.*)$/);
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
					's1:host' => $host,
					's2:algp' => $algo,
					's3:key'  => $key, 
				}});
				
				$anvil->{ssh_keys}{$known_hosts}{host}{$host}{$algo}{key}  = $key;
				$anvil->{ssh_keys}{$known_hosts}{host}{$host}{$algo}{line} = $line_number;
				$anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{algo} = $algo;
				$anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{host} = $host;
				$anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{key}  = $key;
				$anvil->{ssh_key}{$key}{algo}                              = $algo;
				$anvil->{ssh_key}{$key}{host}                              = $host;
				$anvil->{ssh_key}{$key}{asked}                             = 0;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					"s1:ssh_keys::${known_hosts}::host::${host}::${algo}::key"  => $anvil->{ssh_keys}{$known_hosts}{host}{$host}{$algo}{key}, 
					"s2:ssh_keys::${known_hosts}::host::${host}::${algo}::line" => $anvil->{ssh_keys}{$known_hosts}{host}{$host}{$algo}{line}, 
					"s3:ssh_keys::${known_hosts}::line::${line_number}::algo"   => $anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{algo}, 
					"s4:ssh_keys::${known_hosts}::line::${line_number}::host"   => $anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{host}, 
					"s5:ssh_keys::${known_hosts}::line::${line_number}::key"    => $anvil->{ssh_keys}{$known_hosts}{line}{$line_number}{key}, 
					"s6:ssh_key::${key}::algo"                                  => $anvil->{ssh_key}{$key}{algo}, 
					"s7:ssh_key::${key}::host"                                  => $anvil->{ssh_key}{$key}{host}, 
				}});
			}
		}
	}
	
	if ($anvil->data->{switches}{'job-uuid'})
	{
		# Get the job
		my $query = "SELECT job_data FROM jobs WHERE job_uuid = ".$anvil->Database->quote($anvil->data->{switches}{'job-uuid'}).";";
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
		my $results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			results => $results, 
			count   => $count, 
		}});
		
		if (not $count)
		{
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0079", variables => {
				job_uuid => $anvil->data->{switches}{'job-uuid'}, 
			}});
			$anvil->nice_exit({exit_code => 1});
		}
		
		# Pick up the data.
		my $job_data = $results->[0]->[0];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { job_data => $job_data }});
		if (not $job_data)
		{
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0081", variables => {
				job_uuid => $anvil->data->{switches}{'job-uuid'}, 
			}});
			$anvil->nice_exit({exit_code => 1});
		}
		
		# Pick up the job.
		$anvil->data->{job}{progress} = 0;
		update_progress($anvil, 0, "clear");
		
		$anvil->data->{job}{progress} += 5;
		update_progress($anvil, $anvil->data->{job}{progress}, "job_0048");
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 2, key => "job_0048"});
		
		### TODO: Remove the old ways when issue #706 is closed.
		# If this is the old way, job_data is a CSV of state_uuids. If it's the new way, it's the bad key.
		if ($job_data =~ /bad_key=(.*)$/)
		{
			# We're got what we need.
			$anvil->data->{bad_key} = $1;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $anvil->data->{bad_key} }});
		}
		else
		{
			### Ahh, the old ways
			# Break the job up, find the actual bad key(s), and create new job(s).
			foreach my $state_uuid (split/,/, $job_data)
			{
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { state_uuid => $state_uuid }});
				if ($anvil->Validate->uuid({uuid => $state_uuid}))
				{
					# Get the state_note.
					my $query = "SELECT state_note FROM states WHERE state_uuid = ".$anvil->Database->quote($state_uuid).";";
					$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
					
					foreach my $uuid (keys %{$anvil->data->{cache}{database_handle}})
					{
						my $results = $anvil->Database->query({uuid => $uuid, query => $query, source => $THIS_FILE, line => __LINE__});
						my $count   = @{$results};
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							results => $results, 
							count   => $count, 
						}});
						if ($count)
						{
							# Create a new job with the new bad_key job data, one per state_uuid.
							my $state_note = $results->[0]->[0];
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { state_note => $state_note }});
							
							my $bad_key = "";
							if ($state_note =~ /key=(.*?)$/)
							{
								$bad_key = $1;
								$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $bad_key }});
							}
							elsif ($state_note =~ /file=(.*?),line=(\d+)$/)
							{
								# This was the old way, parse out the key.
								my $bad_file = $1;
								my $bad_line = $2;
								$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
									bad_file => $bad_file,
									bad_line => $bad_line,
								}});
								if ($anvil->{ssh_keys}{$bad_file}{line}{$bad_line}{key})
								{
									$bad_key = $anvil->{ssh_keys}{$bad_file}{line}{$bad_line}{key};
									$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $bad_key }});
								}
							}
							my $job_uuid = $anvil->Database->insert_or_update_jobs({
								debug           => 2,
								file            => $THIS_FILE, 
								line            => __LINE__, 
								job_title       => "job_0056",
								job_description => "job_0057",
								job_host_uuid   => $anvil->Get->host_uuid, 
								job_data        => "bad_key=".$bad_key,
								job_command     => $anvil->data->{path}{exe}{'anvil-manage-keys'}.$anvil->Log->switches, 
								job_name        => "manage::broken_keys", 
								job_progress    => 0,
							});
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { job_uuid => $job_uuid }});
							
							# Tell the user we've created a new job.
							my $target = $anvil->{ssh_key}{$bad_key}{host} ? $anvil->{ssh_key}{$bad_key}{host} : "--";
							$anvil->data->{job}{progress} += 5;
							update_progress($anvil, $anvil->data->{job}{progress}, "job_0002,!!job_uuid!".$job_uuid."!!,!!target!".$target."!!");
							$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 1, key => "job_0002", variables => {
								job_uuid => $job_uuid, 
								target   => $target, 
							}});
						}
					}
				}
				else
				{
					# Invalid, skip it.
					$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0082", variables => {
						state_uuid => $state_uuid, 
					}});
				}
			}
			
			# Close this job out now.
			update_progress($anvil, 100, "job_0003");
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 1, key => "job_0003"});
			$anvil->nice_exit({exit_code => 0});
		}
	}
	else
	{
		# No job UUID. Are there known bad keys? If so, show them to the user, one at a time, and ask
		# if they want to remove them. We'll create a job for each one they say yes to.
		my $query = "
SELECT 
    state_uuid, 
    state_name, 
    state_note 
FROM 
    states 
WHERE 
    state_name 
LIKE 
    'host_key_changed::%' 
AND 
    state_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)."
;";

		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
		
		# Collect from all DBs.
		foreach my $uuid (keys %{$anvil->data->{cache}{database_handle}})
		{
			my $results = $anvil->Database->query({uuid => $uuid, query => $query, source => $THIS_FILE, line => __LINE__});
			my $count   = @{$results};
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				results => $results, 
				count   => $count, 
			}});
			if ($count)
			{
				foreach my $row (@{$results})
				{
					my $state_uuid = $row->[0];
					my $state_name = $row->[1];
					my $state_note = $row->[2];
					$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
						's1:state_uuid' => $state_uuid, 
						's2:state_name' => $state_name, 
						's2:state_note' => $state_note, 
					}});
					
					my $bad_key  = "";
					my $bad_file = "";
					my $bad_line = "";
					foreach my $pair (split/,/, $state_note)
					{
						my ($variable, $value) = ($pair =~ /^(.*?)=(.*)$/);
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							pair     => $pair, 
							variable => $variable, 
							value    => $value,
						}});
						if ($variable eq "file")
						{
							$bad_file = $value;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_file => $bad_file }});
						}
						if ($variable eq "line")
						{
							$bad_line = $value;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_line => $bad_line }});
						}
						if ($variable eq "key")
						{
							$bad_key = $value;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $bad_key }});
						}
					}
					
					if ((not $bad_key) && (($bad_file) && ($bad_line)))
					{
						# Find the key.
						if (exists $anvil->{ssh_keys}{$bad_file}{line}{$bad_line}{key})
						{
							$bad_key = $anvil->{ssh_keys}{$bad_file}{line}{$bad_line}{key};
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $bad_key }});
						}
					}
					
					if (not $bad_key)
					{
						# Failed to translate the bad file/line to a key.
						$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0001", variables => {
							file => $bad_file, 
							line => $bad_line,
						}});
					}
					else
					{
						# Have we asked about this key yet?
						if (not $anvil->{ssh_key}{$bad_key}{asked})
						{
							# Nope, ask now.
							$anvil->{ssh_key}{$bad_key}{asked} = 1;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { bad_key => $bad_key }});
							
							my $algo = $anvil->{ssh_key}{$bad_key}{algo};
							my $host = $anvil->{ssh_key}{$bad_key}{host};
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								algo => $algo,
								host => $host, 
							}});
							
							# Did the user confirm already?
							if ($anvil->data->{switches}{confirm})
							{
								# Yup.
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0359", variables => { host => $host }});
							}
							else
							{
								# Ask the user to confirm.
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0362", variables => {
									host => $host, 
									algo => $algo, 
									key  => $bad_key,
								}});
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0363"});
								
								my $answer = <STDIN>;
								chomp $answer;
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, key => "log_0828", variables => { answer => $answer }});
								if ((lc($answer) eq "y") or (lc($answer) eq "yes"))
								{
									# Proceed.
									$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0175"});
								}
								else
								{
									# Skip this key.
									$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0034"});
									next;
								}
							}
							
							# Create a job to remove the key from all hosts.
							foreach my $host_name (sort {$a cmp $b} keys %{$anvil->data->{sys}{hosts}{by_name}})
							{
								my $this_host_uuid = $anvil->data->{sys}{hosts}{by_name}{$host_name};
								my $job_uuid       = $anvil->Database->insert_or_update_jobs({
									debug           => 2,
									file            => $THIS_FILE, 
									line            => __LINE__, 
									job_title       => "job_0056",
									job_description => "job_0057",
									job_host_uuid   => $this_host_uuid, 
									job_data        => "bad_key=".$bad_key,
									job_command     => $anvil->data->{path}{exe}{'anvil-manage-keys'}.$anvil->Log->switches, 
									job_name        => "manage::broken_keys", 
									job_progress    => 0,
								});
								$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { job_uuid => $job_uuid }});
								
								# Tell the user we've created a new job.
								$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 1, key => "job_0002", variables => {
									job_uuid  => $job_uuid, 
									host_name => $host_name, 
									target    => $host, 
								}});
							}
						}
					}
				}
			}
			else
			{
				# No bad keys found, we're done.
				$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "message_0012"});
				$anvil->nice_exit({exit_code => 0});
			}
		}
		# Done looking for keys
		$anvil->nice_exit({exit_code => 0});
	}
	
	return(0);
}

# This deletes a state entry.
sub delete_state
{
	my ($anvil, $state_uuid) = @_;
	
	# Delete it so long as we have a UUID.
	if ($state_uuid)
	{
		my $query = "DELETE FROM states	WHERE state_uuid = ".$anvil->Database->quote($state_uuid).";";
		$anvil->Database->write({debug => 3, query => $query, source => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This updates the progress if we were called with a job UUID.
sub update_progress
{
	my ($anvil, $progress, $message) = @_;
	
	$progress = 95 if $progress > 100;
	
	# Log the progress percentage.
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
		progress => $progress,
		message  => $message, 
	}});
	
	$anvil->Job->update_progress({
		debug    => 3, 
		progress => $progress, 
		message  => $message, 
		job_uuid => $anvil->data->{switches}{'job-uuid'},
	});
	
	return(0);
}
