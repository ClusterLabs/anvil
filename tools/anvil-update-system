#!/usr/bin/perl
# 
# This updates the host system. 
# NOTE: This doesn't update the Anvil! software stack yet, just the OS.
# 
# - On Striker; This will take the system offline and then run 'dnf -y update'. 
# - On Nodes; This will do nothing until all servers are off the node. Then the node will be withdrawn, 
#   updated and then rejoin the cluster.
# - On DR; This will do nothing until no servers are running, then it will update the system.
#  
# In all cases, the system will be rebooted if the kernel is updated.
# 
# Exit codes;
# 0 = Normal exit.
# 1 = No database connections available.
# 2 = The job UUID was passed, but it wasn't valid.
# 3 = It looks like the update failed, reset progress to '0'.

use strict;
use warnings;
use Anvil::Tools;

# Disable buffering
$| = 1;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

my $anvil = Anvil::Tools->new({log_level => 2, log_secure => 1});

$anvil->Storage->read_config({file => "/etc/anvil/anvil.conf"});

# Read switches
$anvil->data->{switches}{'no-reboot'} = 0;
$anvil->data->{switches}{'job-uuid'}  = "";
$anvil->Get->switches;

# Connect to DBs.
$anvil->Database->connect;
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, secure => 0, key => "log_0132"});
if (not $anvil->data->{sys}{db_connections})
{
	# No databases, exit.
	print $anvil->Words->string({key => "error_0003"})."\n";
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, secure => 0, key => "error_0003"});
	$anvil->nice_exit({exit_code => 1});
}

# Did we get called with a job UUID?
if ($anvil->data->{switches}{'job-uuid'})
{
	# Is it set and valid?
	if (not $anvil->Validate->is_uuid({uuid => $anvil->data->{switches}{'job-uuid'}}))
	{
		# It's not a UUID.
		print $anvil->Words->string({key => "error_0033", variables => { uuid => $anvil->data->{switches}{'job-uuid'} }})."\n";
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, secure => 0, key => "error_0033", variables => { uuid => $anvil->data->{switches}{'job-uuid'} } });
		$anvil->nice_exit({code => 2});
	}
	
	# If I'm here, see if we can read the job details.
	my $query = "
SELECT 
    job_host_uuid, 
    job_data, 
    job_updated, 
    job_name,
    job_status 
FROM 
    jobs 
WHERE 
    job_uuid = ".$anvil->data->{sys}{use_db_fh}->quote($anvil->data->{switches}{'job-uuid'})." 
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	my $results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		results => $results, 
		count   => $count, 
	}});
	if ($count < 1)
	{
		print $anvil->Words->string({key => "error_0034", variables => { uuid => $anvil->data->{switches}{'job-uuid'} }})."\n";
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, secure => 0, key => "error_0034", variables => { uuid => $anvil->data->{switches}{'job-uuid'} } });
		$anvil->nice_exit({code => 2});
	}
	
	# If we're here, we're good. Load the details
	$anvil->data->{jobs}{job_uuid}      = $anvil->data->{switches}{'job-uuid'};
	$anvil->data->{jobs}{job_host_uuid} = $results->[0]->[0];
	$anvil->data->{jobs}{job_data}      = $results->[0]->[1];
	$anvil->data->{jobs}{job_updated}   = $results->[0]->[2];
	$anvil->data->{jobs}{job_name}      = $results->[0]->[3];
	$anvil->data->{jobs}{job_status}    = $results->[0]->[4];
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		"jobs::job_uuid"      => $anvil->data->{jobs}{job_uuid}, 
		"jobs::job_host_uuid" => $anvil->data->{jobs}{job_host_uuid},
		"jobs::job_data"      => $anvil->data->{jobs}{job_data}, 
		"jobs::job_updated"   => $anvil->data->{jobs}{job_updated}, 
		"jobs::job_name"      => $anvil->data->{jobs}{job_name}, 
		"jobs::job_status"    => $anvil->data->{jobs}{job_status}, 
	}});
}

# Mark that we're starting
update_progress($anvil, 1);

my ($reboot) = run_os_update($anvil);
$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { reboot => $reboot }});

# We're done updating
update_progress($anvil, 100);

# Reboot if needed.
if (($reboot) && (not $anvil->data->{switches}{'no-reboot'}))
{
	# Reboot.
	$anvil->System->call({shell_call => $anvil->data->{path}{exe}{'shutdown'}." --reboot now"});
}

$anvil->nice_exit({exit_code => 0});

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This updates the progress if we were called with a job UUID.
sub update_progress
{
	my ($anvil, $progress) = @_;
	
	# Log the progress percentage.
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { progress => $progress }});
	
	if ($anvil->data->{jobs}{job_uuid})
	{
		my $query = "
UPDATE 
    jobs 
SET 
    job_picked_up_by = ".$anvil->data->{sys}{use_db_fh}->quote($$).", 
    job_updated      = now(),
    job_progress     = ".$progress.", 
    modified_date    = ".$anvil->data->{sys}{use_db_fh}->quote($anvil->data->{sys}{db_timestamp})." 
WHERE 
    job_uuid         = ".$anvil->data->{sys}{use_db_fh}->quote($anvil->data->{jobs}{job_uuid})." 
";
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
		$anvil->Database->write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This updates the OS.
sub run_os_update
{
	my ($anvil) = @_;
	
	# NOTE: We run this directly to better monitor progress and update the progress.
	my $success       = 0;
	my $to_update     = 0;
	my $percent_step  = 0;
	my $progress      = 5;
	my $counted_lines = 0;
	my $next_step     = 0;
	my $reboot        = 0;
	my $output        = "";
	my $shell_call = $anvil->data->{path}{exe}{dnf}." clean expire-cache && ".$anvil->data->{path}{exe}{dnf}." -y update; ".$anvil->data->{path}{exe}{echo}." return_code:\$?";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { shell_call => $shell_call }});
	open (my $file_handle, $shell_call." 2>&1 |") or $anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, secure => 0, priority => "err", key => "log_0014", variables => { shell_call => $shell_call, error => $! }});
	while(<$file_handle>)
	{
		chomp;
		my $line   =  $_;
		   $output .= $line."\n";
		   $line   =  $anvil->Words->clean_spaces({string => $line});
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { line => $line }});
		
		if ($line =~ /^kernel /)
		{
			# Reboot will be needed.
			$reboot = 1;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { reboot => $reboot }});
		}
		
		if ($line =~ /return_code:(\d+)$/)
		{
			my $return_code = $1;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { return_code => $return_code }});
			if ($return_code == 0)
			{
				$success = 1;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { success => $success }});
			}
		}
		
		if ($line =~ / (\d+) Packages$/i)
		{
			my $counted_lines =  $1;
			   $to_update     += $counted_lines;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				counted_lines => $counted_lines,
				to_update     => $to_update, 
			}});
		}
		
		if ($line =~ /Total download size/i)
		{
			# Ready to install, update to 5%. The next step will count up to 95%.
			update_progress($anvil, $progress);
			
			# The total (reliable) count of events is (to_update * 3), counting '(x/y): ' 
			# (download), 'Upgrading '/'Installing ' and 'Verifying '. We ignore the scriplet
			# and other lines as it's hard to predict how many there will be, and they pass fast
			# enough to not really matter for a progress bar.
			$to_update    *= 4;
			$percent_step =  $anvil->Convert->round({number => ($to_update / 90)});
			$next_step    =  $percent_step;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				to_update    => $to_update, 
				percent_step => $percent_step, 
				next_step    => $next_step, 
			}});
		}
		
		# If 'percent_step' is set, we're ready to start counting lines.
		if (($percent_step) && (($line =~ /\(\d+\/\d+\): /) or ($line =~ /^Upgrading /i) or ($line =~ /^Installing /) or ($line =~ /^Cleanup /i) or ($line =~ /^Verifying /i)))
		{
			$counted_lines++;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { counted_lines => $counted_lines }});
			
			if ($counted_lines > $next_step)
			{
				# Step up the progress.
				$next_step += $percent_step;
				$progress++;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
					next_step => $next_step,
					progress  => $progress, 
				}});
				next if $progress > 95;
				
				update_progress($anvil, $progress);
			}
		}
	}
	close $file_handle;
	
	# Did it work?
	if (not $success)
	{
		# Nope.
		update_progress($anvil, 0);
		
		print $anvil->Words->string({key => "error_0035", variables => { output => $output }})."\n";
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 0, secure => 0, key => "error_0035", variables => { output => $output } });
		$anvil->nice_exit({code => 3});
	}
	
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { reboot => $reboot }});
	return($reboot);
};
