#!/usr/bin/perl
#
# Manages VNC ports for server VMs that have VNC enabled.
#

use strict;
use warnings;
use Anvil::Tools;

$| = 1;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

my $anvil = Anvil::Tools->new();

sub call
{
	my $parameters  = shift;
	my $host_name   = $parameters->{host_name} // $anvil->data->{sys}{host_name};
	my $remote_user = $parameters->{remote_user};
	my $shell_call  = $parameters->{shell_call};

	my $shell_output;
	my $shell_error;
	my $shell_return_code;

	my $is_remote_call = is_remote_host_name($host_name);

	if ($is_remote_call)
	{
		($shell_output, $shell_error, $shell_return_code) = $anvil->Remote->call({
			target      => $host_name,
			remote_user => $remote_user,
			shell_call  => $shell_call
		});
	}
	else
	{
		($shell_output, $shell_return_code) = $anvil->System->call({ shell_call => $shell_call });
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		host_name         => $host_name,
		is_remote_call    => $is_remote_call,
		remote_user       => $remote_user,
		shell_call        => $shell_call,
		shell_output      => $shell_output,
		shell_error       => $shell_error,
		shell_return_code => $shell_return_code
	}, prefix => "call" });

	return ($shell_output, $shell_error, $shell_return_code);
}

sub get_server_info
{
	my $parameters       = shift;
	my $server_host_name = $parameters->{server_host_name};
	my $server_host_uuid = $parameters->{server_host_uuid};
	my $server_name      = $parameters->{server_name};
	my $server_uuid      = $parameters->{server_uuid};

	return if (not defined $server_uuid);

	my $query;
	my $server_info;

	# When all required server info are provided, i.e., extracted from
	# libvirt domain XML, simply return the values.
	if (defined $server_host_name and defined $server_host_uuid and defined $server_name)
	{
		$server_info = {
			host_name   => $server_host_name,
			host_uuid   => $server_host_uuid,
			server_name => $server_name
		};

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $server_info, prefix => "get_server_info" });

		return $server_info;
	}

	if (defined $server_host_uuid)
	{
		$query = "
SELECT a.server_name, b.host_name, b.host_uuid
FROM servers AS a, hosts AS b
WHERE server_uuid = ".$anvil->Database->quote($server_uuid)."
AND host_uuid = ".$anvil->Database->quote($server_host_uuid)."
;";
	}
	else
	{
		$query = "
SELECT a.server_name, b.host_name, b.host_uuid
FROM servers AS a
JOIN hosts AS b ON a.server_host_uuid = b.host_uuid
WHERE server_uuid = ".$anvil->Database->quote($server_uuid)."
;";
	}

	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query, count => $count }, prefix => "get_server_info" });

	if ($count == 1)
	{
		my $row = $results->[0];

		$server_info = {};
		$server_info->{server_name} = $row->[0];
		$server_info->{host_name}   = $row->[1];
		$server_info->{host_uuid}   = $row->[2];

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $server_info, prefix => "get_server_info" });
	}

	return $server_info;
}

sub get_vnc_info
{
	my $parameters  = shift;
	my $host_name   = $parameters->{host_name};
	my $port        = $parameters->{port};
	my $port_base   = $parameters->{port_base} // 5900;
	my $server_name = $parameters->{server_name};
	my $server_uuid = $parameters->{server_uuid};

	my $port_offset;
	my $vnc_info;

	if ( (not defined $port) or (not $port =~ /^\d+$/) )
	{
		# Requires root to access VM information.
		my $shell_call = "virsh vncdisplay ".$server_name;

		my ($shell_output, $shell_error, $shell_return_code) = call({
			host_name   => $host_name,
			remote_user => "root",
			shell_call  => $shell_call
		});

		return if ($shell_return_code != 0);

		($port_offset) = $shell_output =~ /:(\d+)$/;
		$port          = $port_base + int($port_offset);
	}
	else
	{
		$port = int($port);
	}

	$vnc_info = { host_name => $host_name, port => $port };

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		port_offset => $port_offset,
		vnc_port    => $vnc_info->{port}
	}, prefix => "get_vnc_info" });

	return $vnc_info;
}

sub get_available_port
{
	my $parameters    = shift;
	my $start_port    = $parameters->{start_port};
	my $host_name     = $parameters->{host_name};
	my $step_operator = ((defined $parameters->{step_operator}) and ($parameters->{step_operator} =~ /^[+-]$/)) ? $parameters->{step_operator} : "+";
	my $step_size     = (
		(defined $parameters->{step_size})
		and ($parameters->{step_size} =~ /^\d+$/)
		and ($parameters->{step_size} > 0)
	) ? $parameters->{step_size} : 1;

	my $available_port;

	my $shell_call = "ss_output=\$(ss --all --tcp --numeric) && port=".$start_port." && while egrep -q \":\${port}[[:space:]]+[^[:space:]]+\" <<<\$ss_output; do (( port ".$step_operator."= ".$step_size." )); done && echo \$port";

	my ($shell_output, $shell_error, $shell_return_code) = call({ host_name => $host_name, shell_call => $shell_call });

	if ($shell_return_code == 0)
	{
		$available_port = $shell_output;
	}

	return $available_port;
}

sub is_websockify_process
{
	my $parameters = shift;
	my $host_name  = $parameters->{host_name};
	my $ws_pid     = $parameters->{ws_pid};
	my $shell_call = "ps -e -o command -h -p ".$ws_pid;

	my ($shell_output, $shell_error, $shell_return_code) = call({ host_name  => $host_name, shell_call => $shell_call });

	return $shell_output =~ /websockify/ ? 1 : 0;
}

sub is_ssh_process
{
	my $parameters     = shift;
	my $host_name      = $parameters->{host_name};
	my $ssh_tunnel_pid = $parameters->{ssh_tunnel_pid};

	my $shell_call = "ps -e -o command -h -p ".$ssh_tunnel_pid;

	my ($shell_output) = call({ host_name => $host_name, shell_call => $shell_call });

	return $shell_output =~ /striker-open-ssh-tunnel/ ? 1 : 0;
}

sub is_websockify_exists
{
	my $parameters      = shift;
	my $server_uuid     = $parameters->{server_uuid};
	my $host_uuid       = $parameters->{host_uuid};
	my $ws_host_uuid    = $parameters->{ws_host_uuid};
	my $server_vnc_port = $parameters->{server_vnc_port};

	# Expect 0 to 1 record(s) because each VM server can only have 1
	# websockify instance (not considering shared VNC sessions).
	my $query = "
SELECT
	a.server_vnc_port,
	b.host_name,
	a.ws_host_uuid,
	a.ws_pid,
	a.ws_dest_port,
	a.ssh_tunnel_host_uuid
FROM vnc_pipes AS a
JOIN hosts AS b ON a.ws_host_uuid = b.host_uuid
WHERE
	a.server_uuid = ".$anvil->Database->quote($server_uuid)."
AND
	a.ws_host_uuid = ".$anvil->Database->quote($ws_host_uuid)."
AND
	a.server_vnc_port IS NOT NULL
ORDER BY a.ws_pid DESC
;";

	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query, count => $count }, prefix => "is_websockify_exists" });

	my $ws_exists_info = { exists_code => 0 };

	foreach my $row (@{$results})
	{
		my $server_vnc_port_in_record = $row->[0];
		my $ws_host_name              = $row->[1];
		my $ws_host_uuid_in_record    = $row->[2];
		my $ws_pid                    = $row->[3];
		my $ws_dest_port              = $row->[4];
		my $ssh_tunnel_host_uuid      = $row->[5];
		my $clean_up_parameters       = { host_name => $ws_host_name, ws_pid => $ws_pid };

		$ws_exists_info->{exists_code} = 1;

		if ($ws_host_uuid ne $ws_host_uuid_in_record)
		{
			# VNC server host mismatch; try to stop the recorded instance.
			# Likely happens after a server migration.
			stop_websockify($clean_up_parameters);

			# No need to preserve the websockify source port in
			# this case because the tunnel will need to be replaced
			# as well.
		}
		elsif ($server_vnc_port != $server_vnc_port_in_record)
		{
			# VNC server port mismatch; try to stop the recorded instance.
			stop_websockify($clean_up_parameters);

			$ws_exists_info->{ws_dest_port} = $ws_dest_port;
		}
		elsif (not is_websockify_process($clean_up_parameters))
		{
			# The recorded instance died.
			$ws_exists_info->{ws_dest_port} = $ws_dest_port;
		}
		else
		{
			# Found one websockify instance that passed all tests.
			$ws_exists_info->{exists_code}  = 2;
			$ws_exists_info->{ws_pid}       = $ws_pid;
			$ws_exists_info->{ws_dest_port} = $ws_dest_port;
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ws_exists_info, prefix => "is_websockify_exists" });

	return $ws_exists_info;
}

sub is_ssh_tunnel_exists
{
	my $parameters           = shift;
	my $server_uuid          = $parameters->{server_uuid};
	my $ssh_tunnel_host_uuid = $parameters->{ssh_tunnel_host_uuid};
	my $ws_host_uuid         = $parameters->{ws_host_uuid};
	my $ws_dest_port         = $parameters->{ws_dest_port};

	# Expect 0 to n record(s), where n is the number of subnodes:
	# n=0: no SSH tunnel connected to the server's ws instance
	# n>0: at least one SSH tunnel is known, regardless of whether it is
	#      actually alive
	#
	# Order by clause ensures NULL record(s) are at first.
	my $query = "
SELECT
	a.ws_host_uuid,
	a.ws_pid,
	a.ws_dest_port,
	a.ssh_tunnel_dest_port,
	b.host_name,
	a.ssh_tunnel_host_uuid,
	a.ssh_tunnel_pid,
	a.ssh_tunnel_source_port
FROM vnc_pipes AS a
JOIN hosts AS b ON a.ssh_tunnel_host_uuid = b.host_uuid
WHERE
	a.server_uuid = ".$anvil->Database->quote($server_uuid)."
AND
	a.ssh_tunnel_host_uuid IS NOT NULL
ORDER BY a.ws_pid DESC
;";

	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query, count => $count }, prefix => "is_ssh_tunnel_exists" });

	my $ssh_tunnel_exists_info = { exists_code => 0 };

	foreach my $row (@{$results})
	{
		my $row                            = $results->[0];
		my $ws_host_uuid_in_record         = $row->[0];
		my $ws_pid_in_record               = $row->[1];
		my $ws_dest_port_in_record         = $row->[2];
		my $ssh_tunnel_dest_port           = $row->[3];
		my $ssh_tunnel_host_name           = $row->[4];
		my $ssh_tunnel_host_uuid_in_record = $row->[5];
		my $ssh_tunnel_pid                 = $row->[6];
		my $ssh_tunnel_source_port         = $row->[7];
		my $clean_up_parameters            = { host_name => $ssh_tunnel_host_name, ssh_tunnel_pid => $ssh_tunnel_pid };

		$ssh_tunnel_exists_info->{exists_code} = 1;

		if (not defined $ws_pid_in_record and defined $ssh_tunnel_pid)
		{
			# Websockify instance doesn't exist but tunnel does.
			# Remove the tunnel that's not connected to anything.
			stop_ssh_tunnel($clean_up_parameters);

			clear_vnc_pipe_st({ server_uuid => $server_uuid, ws_host_uuid => $ws_host_uuid_in_record });

			# No need to preserve any tunnel info because this
			# tunnel doesn't need to be recreated.
		}
		elsif ($ssh_tunnel_source_port != $ws_dest_port_in_record)
		{
			# Tunnel is not pointing to the destination port of the
			# websockify instance; stop it and recreate.
			stop_ssh_tunnel($clean_up_parameters);

			# Port mismatch means we need to recreate the tunnel.
			$ssh_tunnel_exists_info->{ssh_tunnel_dest_port} = $ssh_tunnel_dest_port;
		}
		elsif (not is_ssh_process($clean_up_parameters))
		{
			# The tunnel pid doesn't point to an active tunnel;
			# mark as need-to-be recreated.
			$ssh_tunnel_exists_info->{ssh_tunnel_dest_port} = $ssh_tunnel_dest_port;
		}
		else
		{
			# Passed all tests; tunnel considered exists.
			$ssh_tunnel_exists_info->{exists_code}          = 2;
			$ssh_tunnel_exists_info->{ssh_tunnel_dest_port} = $ssh_tunnel_dest_port;
			$ssh_tunnel_exists_info->{ssh_tunnel_pid}       = $ssh_tunnel_pid;
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ssh_tunnel_exists_info, prefix => "is_ssh_tunnel_exists" });

	return $ssh_tunnel_exists_info;
}

sub is_websockify_in_use_by_others
{
	my $parameters = shift;
	my $ws_pid     = $parameters->{ws_pid};

	my $query = "SELECT COUNT(*) FROM public.vnc_pipes WHERE ws_pid = ".$anvil->Database->quote($ws_pid).";";

	my $count = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ })->[0]->[0];

	return $count > 1 ? 1 : 0;
}

sub is_remote_host_name
{
	my $host_name = shift;

	return ((defined $host_name) and ($host_name ne $anvil->data->{sys}{host_name})) ? 1 : 0;
}

sub start_websockify
{
	my $parameters   = shift;
	my $server_uuid  = $parameters->{server_uuid};
	my $host_uuid    = $parameters->{host_uuid};
	my $ws_host_name = $parameters->{ws_host_name};
	my $ws_host_uuid = $parameters->{ws_host_uuid};
	my $target_port  = $parameters->{target_port};
	my $source_port  = $parameters->{source_port};
	my $ws_info;

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "start_websockify" });

	my $ws_exists_info = is_websockify_exists({
		server_uuid     => $server_uuid,
		host_uuid       => $host_uuid,
		ws_host_uuid    => $ws_host_uuid,
		server_vnc_port => $target_port
	});

	if ($ws_exists_info->{exists_code} == 2)
	{
		$ws_info                = {};
		$ws_info->{pid}         = $ws_exists_info->{ws_pid};
		$ws_info->{source_port} = $ws_exists_info->{ws_dest_port};
	}
	else
	{
		if (not defined $source_port)
		{
			if (defined $ws_exists_info->{ws_dest_port})
			{
				$source_port = $ws_exists_info->{ws_dest_port};
			}
			else
			{
				my $source_port_base = 10000;

				$source_port = $source_port_base + $target_port;
			}
		}

		$source_port = get_available_port({ start_port => $source_port, host_name => $ws_host_name });

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
			source_port => $source_port
		}, prefix => "start_websockify" });

		return if (not defined $source_port);

		my $shell_call = "websockify ".$source_port." :".$target_port." &>/dev/null & echo pid:\$!";

		my ($shell_output, $shell_error, $shell_return_code) = call({
			host_name   => $ws_host_name,
			remote_user => "admin",
			shell_call  => $shell_call
		});

		return if ($shell_return_code != 0);

		my ($ws_pid) = $shell_output =~ /pid:(\d+)$/;

		$ws_info                = {};
		$ws_info->{pid}         = $ws_pid;
		$ws_info->{source_port} = $source_port;

		if ($ws_exists_info->{exists_code} == 1)
		{
			$ws_info->{is_update} = 1;
		}
		else
		{
			$ws_info->{is_new} = 1;
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ws_info, prefix => "start_websockify" });

	return $ws_info;
}

sub stop_websockify
{
	my $parameters = shift;
	my $host_name  = $parameters->{host_name};
	my $ws_pid     = $parameters->{ws_pid};

	return if (not is_websockify_process($parameters));

	call({ host_name  => $host_name, shell_call => "kill $ws_pid || kill -9 $ws_pid" });
}

sub start_ssh_tunnel
{
	my $parameters           = shift;
	my $server_uuid          = $parameters->{server_uuid};
	my $host_name            = $parameters->{host_name};
	my $host_uuid            = $parameters->{host_uuid};
	my $ws_host_name         = $parameters->{ws_host_name};
	my $ws_host_uuid         = $parameters->{ws_host_uuid};
	my $ws_dest_port         = $parameters->{ws_dest_port};
	my $ssh_tunnel_dest_port = $parameters->{ssh_tunnel_dest_port};
	my $ssh_tunnel_info;

	my $ssh_tunnel_exists_info = is_ssh_tunnel_exists({
		server_uuid          => $server_uuid,
		ssh_tunnel_host_uuid => $host_uuid,
		ws_host_uuid         => $ws_host_uuid,
		ws_dest_port         => $ws_dest_port
	});

	if ($ssh_tunnel_exists_info->{exists_code} == 2)
	{
		$ssh_tunnel_info                 = {};
		$ssh_tunnel_info->{pid}          = $ssh_tunnel_exists_info->{ssh_tunnel_pid};
		$ssh_tunnel_info->{forward_port} = $ssh_tunnel_exists_info->{ssh_tunnel_dest_port};
	}
	else
	{
		if (not defined $ssh_tunnel_dest_port)
		{
			if (defined $ssh_tunnel_exists_info->{ssh_tunnel_dest_port})
			{
				$ssh_tunnel_dest_port = $ssh_tunnel_exists_info->{ssh_tunnel_dest_port};
			}
			else
			{
				$ssh_tunnel_dest_port = $ws_dest_port;
			}
		}

		$ssh_tunnel_dest_port = get_available_port({ start_port => $ssh_tunnel_dest_port });

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
			ssh_tunnel_dest_port => $ssh_tunnel_dest_port
		}, prefix => "start_ssh_tunnel" });

		if (not defined $ssh_tunnel_dest_port)
		{
			return;
		}

		my $shell_call = $anvil->data->{path}{exe}{'striker-open-ssh-tunnel'}
			." --remote-user admin --target ".$ws_host_name
			." --forward-local-port ".$ssh_tunnel_dest_port
			." --forward-remote-port ".$ws_dest_port
			." &>/dev/null & echo pid:\$!";

		my ($shell_output, $shell_error, $shell_return_code) = call({ host_name => $host_name, shell_call => $shell_call });

		if ($shell_return_code == 0)
		{
			my ($ssh_tunnel_pid) = $shell_output =~ /pid:(\d+)$/;

			$ssh_tunnel_info                 = {};
			$ssh_tunnel_info->{pid}          = $ssh_tunnel_pid;
			$ssh_tunnel_info->{forward_port} = $ssh_tunnel_dest_port;

			if ($ssh_tunnel_exists_info->{exists_code} == 1)
			{
				$ssh_tunnel_info->{is_update} = 1;
			}
			else
			{
				$ssh_tunnel_info->{is_new} = 1;
			}
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ssh_tunnel_info, prefix => "start_ssh_tunnel" });

	return $ssh_tunnel_info;
}

sub stop_ssh_tunnel
{
	my $parameters     = shift;
	my $host_name      = $parameters->{host_name};
	my $ssh_tunnel_pid = $parameters->{ssh_tunnel_pid};

	return if (not is_ssh_process($parameters));

	call({ host_name => $host_name, shell_call => "kill $ssh_tunnel_pid || kill -9 $ssh_tunnel_pid" });
}

sub create_vnc_pipes_table
{
	my $query = "
CREATE TABLE IF NOT EXISTS public.vnc_pipes (
	uuid			uuid				not null	primary key,
	server_uuid		uuid				not null,
	server_vnc_port		numeric,
	ws_host_uuid		uuid,
	ws_pid			numeric,
	ws_dest_port		numeric,
	ssh_tunnel_dest_port	numeric,
	ssh_tunnel_host_uuid	uuid,
	ssh_tunnel_pid		numeric,
	ssh_tunnel_source_port	numeric,
	modified_date		timestamp with time zone	not null,
	unique(server_uuid, ws_host_uuid)
);";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });
}

sub drop_vnc_pipes_table
{
	my $query = "DROP TABLE IF EXISTS public.vnc_pipes;";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });
}

sub insert_or_update_vnc_pipe
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};

	return (1) if (not defined $server_uuid);

	my $server_vnc_port        = $parameters->{server_vnc_port};
	my $ssh_tunnel_dest_port   = $parameters->{ssh_tunnel_dest_port};
	my $ssh_tunnel_host_uuid   = $parameters->{ssh_tunnel_host_uuid};
	my $ssh_tunnel_pid         = $parameters->{ssh_tunnel_pid};
	my $ssh_tunnel_source_port = $parameters->{ssh_tunnel_source_port};
	my $vnc_pipe_uuid          = $parameters->{vnc_pipe_uuid} // $anvil->Get->uuid();
	my $ws_host_uuid           = $parameters->{ws_host_uuid};
	my $ws_pid                 = $parameters->{ws_pid};
	my $ws_dest_port           = $parameters->{ws_dest_port};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "insert_or_update_vnc_pipe" });

	my $vnc_pipe_mdate        = $anvil->Database->refresh_timestamp();
	my $quoted_vnc_pipe_mdate = $anvil->Database->quote($vnc_pipe_mdate);

	my $insert_columns = "";
	my $insert_values  = "";
	my $update_values  = "";

	foreach my $column_name (
		"server_vnc_port",
		"ws_host_uuid",
		"ws_pid",
		"ws_dest_port",
		"ssh_tunnel_dest_port",
		"ssh_tunnel_host_uuid",
		"ssh_tunnel_pid",
		"ssh_tunnel_source_port"
	)
	{
		my $column_value = $parameters->{$column_name};

		next if (not defined $column_value);

		my $quoted_value = ($column_value eq "NULL")
			? $column_value
			: $anvil->Database->quote($column_value);

		$insert_columns .= "$column_name,\n\t";
		$insert_values  .= "$quoted_value,\n\t";
		$update_values  .= "$column_name = $quoted_value,\n\t";
	}

	my $query = "
INSERT INTO public.vnc_pipes (
	uuid,
	server_uuid,
	$insert_columns
	modified_date
) VALUES (
	".$anvil->Database->quote($vnc_pipe_uuid).",
	".$anvil->Database->quote($server_uuid).",
	$insert_values
	$quoted_vnc_pipe_mdate
) ON CONFLICT (server_uuid, ws_host_uuid) DO UPDATE SET
	$update_values
	modified_date = $quoted_vnc_pipe_mdate;";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });

	return (0);
}

sub clear_vnc_pipe_ws
{
	my $parameters   = shift;
	my $server_uuid  = $parameters->{server_uuid};
	my $ws_host_uuid = $parameters->{ws_host_uuid};

	return (1) if (not defined $ws_host_uuid);

	insert_or_update_vnc_pipe({
		server_uuid     => $server_uuid,
		server_vnc_port => "NULL",
		ws_dest_port    => "NULL",
		ws_host_uuid    => $ws_host_uuid,
		ws_pid          => "NULL"
	});

	return (0);
}

sub clear_vnc_pipe_st
{
	my $parameters = shift;
	my $server_uuid  = $parameters->{server_uuid};
	my $ws_host_uuid = $parameters->{ws_host_uuid};

	return (1) if (not defined $ws_host_uuid);

	insert_or_update_vnc_pipe({
		server_uuid            => $server_uuid,
		ssh_tunnel_dest_port   => "NULL",
		ssh_tunnel_host_uuid   => "NULL",
		ssh_tunnel_pid         => "NULL",
		ssh_tunnel_source_port => "NULL",
		ws_host_uuid           => $ws_host_uuid
	});
}

sub get_vnc_pipe
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};

	return if (not defined $server_uuid);

	my $is_ws_pid            = $parameters->{is_ws_pid};
	my $ssh_tunnel_host_uuid = $parameters->{ssh_tunnel_host_uuid};
	my $ws_host_uuid         = $parameters->{ws_host_uuid};

	my $vnc_pipe_info;

	my $cond_ws_pid     = defined $is_ws_pid
		? "AND a.ws_pid IS NOT NULL" : "";
	my $cond_ssht_huuid = defined $ssh_tunnel_host_uuid
		? "AND a.ssh_tunnel_host_uuid = ".$anvil->Database->quote($ssh_tunnel_host_uuid) : "";
	my $cond_ws_huuid   = defined $ws_host_uuid
		? "AND a.ws_host_uuid = ".$anvil->Database->quote($ws_host_uuid) : "";

	my $query = "
SELECT
	a.server_vnc_port,
	b.host_name,
	a.ws_host_uuid,
	a.ws_pid,
	a.ws_dest_port,
	a.ssh_tunnel_host_uuid,
	a.ssh_tunnel_pid,
	a.ssh_tunnel_dest_port
FROM
	public.vnc_pipes AS a
JOIN
	public.hosts AS b
ON
	a.ws_host_uuid = b.host_uuid
WHERE
	server_uuid = ".$anvil->Database->quote($server_uuid)."
	$cond_ws_pid
	$cond_ssht_huuid
	$cond_ws_huuid
ORDER BY
	a.modified_date DESC
;";

	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query, count => $count }, prefix => "get_vnc_pipe" });

	if ($count == 1)
	{
		my $row = $results->[0];

		$vnc_pipe_info                         = {};
		$vnc_pipe_info->{server_vnc_port}      = $row->[0];
		$vnc_pipe_info->{host_name}            = $row->[1];
		$vnc_pipe_info->{ws_host_uuid}         = $row->[2];
		$vnc_pipe_info->{ws_pid}               = $row->[3];
		$vnc_pipe_info->{ws_dest_port}         = $row->[4];
		$vnc_pipe_info->{ssh_tunnel_host_uuid} = $row->[5];
		$vnc_pipe_info->{ssh_tunnel_pid}       = $row->[6];
		$vnc_pipe_info->{ssh_tunnel_dest_port} = $row->[7];
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $vnc_pipe_info, prefix => "get_vnc_pipe" });

	return $vnc_pipe_info;
}

sub open_ws
{
	my $parameters       = shift;
	my $server_host_name = $parameters->{server_host_name};
	my $server_host_uuid = $parameters->{server_host_uuid};
	my $server_name      = $parameters->{server_name};
	my $server_uuid      = $parameters->{server_uuid};
	my $server_vnc_port  = $parameters->{server_vnc_port};

	my $server_info = $parameters->{server_info} // get_server_info($parameters);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "open_ws" });

	return (1, "error_0313") if (not defined $server_info);

	my $vnc_info = get_vnc_info({
		host_name   => $server_info->{host_name},
		port        => $server_vnc_port,
		server_name => $server_info->{server_name},
		server_uuid => $server_uuid
	});

	return (1, "error0314") if (not defined $vnc_info);

	my $ws_info = start_websockify({
		server_uuid  => $server_uuid,
		target_port  => $vnc_info->{port},
		ws_host_name => $server_info->{host_name},
		ws_host_uuid => $server_info->{host_uuid}
	});

	return (1, "error_0315") if (not defined $ws_info);

	if ($ws_info->{is_new} or $ws_info->{is_update})
	{
		insert_or_update_vnc_pipe({
			server_uuid     => $server_uuid,
			server_vnc_port => $vnc_info->{port},
			ws_host_uuid    => $server_info->{host_uuid},
			ws_pid          => $ws_info->{pid},
			ws_dest_port    => $ws_info->{source_port}
		});
	}

	return (0, $ws_info);
}

sub close_ws
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $vnc_pipe_info = $parameters->{vnc_pipe_info} // get_vnc_pipe({ server_uuid => $server_uuid, ws_host_uuid => $host_uuid });

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "close_ws" });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	return (0) if is_websockify_in_use_by_others({ ws_pid => $vnc_pipe_info->{ws_pid} });

	stop_websockify({ host_name => $vnc_pipe_info->{host_name}, ws_pid => $vnc_pipe_info->{ws_pid} });

	clear_vnc_pipe_ws({ server_uuid  => $server_uuid, ws_host_uuid => $vnc_pipe_info->{ws_host_uuid} });

	return (0);
}

sub open_st
{
	my $parameters       = shift;
	my $host_uuid        = $parameters->{host_uuid};
	my $is_print         = $parameters->{print} // (not $anvil->data->{switches}{'job-uuid'});
	my $server_host_uuid = $parameters->{server_host_uuid};
	my $server_uuid      = $parameters->{server_uuid};

	my $server_info = $parameters->{server_info} // get_server_info($parameters);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "open_st" });

	return (1, "error_0313") if (not defined $server_info);

	my $vnc_pipe_info = get_vnc_pipe({ is_ws_pid => 1, server_uuid => $server_uuid, ws_host_uuid => $server_info->{host_uuid} });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	my $ssh_tunnel_info = start_ssh_tunnel({
		server_uuid  => $server_uuid,
		host_uuid    => $host_uuid,
		ws_host_name => $vnc_pipe_info->{host_name},
		ws_host_uuid => $vnc_pipe_info->{ws_host_uuid},
		ws_dest_port => $vnc_pipe_info->{ws_dest_port}
	});

	return (1, "error_0316") if (not defined $ssh_tunnel_info);

	if ($ssh_tunnel_info->{is_new} or $ssh_tunnel_info->{is_update})
	{
		insert_or_update_vnc_pipe({
			server_uuid            => $server_uuid,
			ssh_tunnel_dest_port   => $ssh_tunnel_info->{forward_port},
			ssh_tunnel_host_uuid   => $host_uuid,
			ssh_tunnel_pid         => $ssh_tunnel_info->{pid},
			ssh_tunnel_source_port => $vnc_pipe_info->{ws_dest_port},
			ws_host_uuid           => $vnc_pipe_info->{ws_host_uuid}
		});
	}

	my $forward_port = $ssh_tunnel_info->{forward_port} // "";

	$ssh_tunnel_info->{forward_port} = $forward_port;

	print "protocol:ws,forward_port:$forward_port\n" if ($is_print);

	return (0, $ssh_tunnel_info);
}

sub close_st
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $vnc_pipe_info = $parameters->{vnc_pipe_info} // get_vnc_pipe({
		server_uuid          => $server_uuid,
		ssh_tunnel_host_uuid => $host_uuid
	});

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters, prefix => "close_st" });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	stop_ssh_tunnel({ ssh_tunnel_pid => $vnc_pipe_info->{ssh_tunnel_pid} });

	clear_vnc_pipe_st({ server_uuid => $server_uuid, ws_host_uuid => $vnc_pipe_info->{ws_host_uuid} });

	return (0);
}

$anvil->Get->switches;

$anvil->Database->connect;
$anvil->Log->entry({ source => $THIS_FILE, line => __LINE__, level => 2, secure => 0, key => "log_0132" });
if (not $anvil->data->{sys}{database}{connections})
{
	# No databases, exit.
	$anvil->Log->entry({ source => $THIS_FILE, line => __LINE__, level => 0, 'print' => 1, priority => "err", key => "error_0003" });
	$anvil->nice_exit({ exit_code => 1 });
}

# Try to get a job UUID if not given.
if (not $anvil->data->{switches}{'job-uuid'})
{
	$anvil->data->{switches}{'job-uuid'} = $anvil->Job->get_job_uuid({ program => $THIS_FILE });
	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		"switches::job-uuid" => $anvil->data->{switches}{'job-uuid'}
	} });
}

# Handle this script as a job when job UUID is provided.
if ($anvil->data->{switches}{'job-uuid'})
{
	$anvil->Job->clear();
	$anvil->Job->get_job_details();
	$anvil->Job->update_progress({
		progress         => 1,
		job_picked_up_by => $$,
		job_picked_up_at => time,
		message          => "message_0259"
	});

	foreach my $line (split/\n/, $anvil->data->{jobs}{job_data})
	{
		if ($line =~ /server-uuid=(.*?)$/)
		{
			$anvil->data->{switches}{'server-uuid'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::server-uuid' => $anvil->data->{switches}{'server-uuid'}
			} });
		}

		if ($line =~ /open=(.*?)$/)
		{
			$anvil->data->{switches}{'open'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::open' => $anvil->data->{switches}{'open'}
			} });
		}

		if ($line =~ /drop-table=(.*?)$/)
		{
			$anvil->data->{switches}{'drop-table'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::drop-table' => $anvil->data->{switches}{'drop-table'}
			} });
		}
	}
}

$anvil->Database->get_hosts();
$anvil->Database->get_anvils();

my $component        = $anvil->data->{switches}{'component'} // "all";
my $is_drop_table    = $anvil->data->{switches}{'drop-table'};
my $is_open          = $anvil->data->{switches}{'open'};
my $server           = $anvil->data->{switches}{'server'};
my $server_host_uuid = $anvil->data->{switches}{'server-host-uuid'};
my $server_uuid      = $anvil->data->{switches}{'server-uuid'} // $anvil->Get->server_uuid_from_name({ server_name => $server });
my $server_vnc_port  = $anvil->data->{switches}{'server-vnc-port'};

my $server_host_name;

if (defined $server_host_uuid)
{
	if ($server_host_uuid eq "local")
	{
		$server_host_uuid = $anvil->data->{sys}{host_uuid};
		$server_host_name = $anvil->data->{sys}{host_name};
	}
	else
	{
		$server_host_name = $anvil->Get->host_name_from_uuid({ host_uuid => $server_host_uuid });
	}
}

$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
	component        => $component,
	is_open          => $is_open,
	is_drop_table    => $is_drop_table,
	server           => $server,
	server_host_name => $server_host_name,
	server_host_uuid => $server_host_uuid,
	server_uuid      => $server_uuid,
	server_vnc_port  => $server_vnc_port
} });

my $map_to_operation = {
	st  => { close => \&close_st, open => \&open_st },
	ws  => { close => \&close_ws, open => \&open_ws },
};

if ($server_uuid =~ /[a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}/)
{
	create_vnc_pipes_table();

	my $ops = $map_to_operation->{$component};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ops });

	$anvil->nice_exit({ exit_code => 1 }) if (not defined $ops);

	my $op = ($is_open) ? "open" : "close";

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { operation => $op } });

	my $host_uuid = $anvil->data->{sys}{host_uuid};

	my ($is_error, $error) = $ops->{$op}({
		host_uuid        => $host_uuid,
		server_host_name => $server_host_name,
		server_host_uuid => $server_host_uuid,
		server_name      => $server,
		server_uuid      => $server_uuid,
		server_vnc_port  => $server_vnc_port
	});

	if ($is_error)
	{
		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 1, list => {
			error       => $error,
			host_uuid   => $host_uuid,
			server_uuid => $server_uuid
		} });

		if (defined $error and $error =~ /^error_/)
		{
			$anvil->Job->update_progress({
				progress   => 100,
				message    => "$error,!!server_uuid!$server_uuid!!,!!host_uuid!$host_uuid!!",
				job_status => "failed"
			});
		}

		$anvil->nice_exit({ exit_code => 2 });
	}

	$anvil->Job->update_progress({
		progress => 100,
		message  => "message_0260,!!operation!$op!!,!!server_uuid!$server_uuid!!,!!host_uuid!$host_uuid!!"
	});
}
elsif ($is_drop_table)
{
	drop_vnc_pipes_table();

	$anvil->Job->update_progress({ progress => 100, message => "message_0261" });
}
else
{
	$anvil->Job->update_progress({ progress => 100, message => "message_0262" });

	$anvil->nice_exit({ exit_code => 3 });
}

$anvil->nice_exit({ exit_code => 0 });
