#!/usr/bin/perl
#
# Manages VNC ports for server VMs that have VNC enabled.
#

use strict;
use warnings;
use Anvil::Tools;

$| = 1;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

my $anvil = Anvil::Tools->new();

sub call
{
	my $parameters  = shift;
	my $host_name   = $parameters->{host_name} // $anvil->data->{sys}{host_name};
	my $remote_user = $parameters->{remote_user};
	my $shell_call  = $parameters->{shell_call};

	my $shell_output;
	my $shell_error;
	my $shell_return_code;

	my $is_remote_call = is_remote_host_name($host_name);

	if ($is_remote_call)
	{
		($shell_output, $shell_error, $shell_return_code) = $anvil->Remote->call({
			target      => $host_name,
			remote_user => $remote_user,
			shell_call  => $shell_call
		});
	}
	else
	{
		($shell_output, $shell_return_code) = $anvil->System->call({ shell_call => $shell_call });
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		shell_call        => $shell_call,
		shell_output      => $shell_output,
		shell_error       => $shell_error,
		shell_return_code => $shell_return_code
	} });

	return ($shell_output, $shell_error, $shell_return_code);
}

sub get_server_info
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};
	my $server_info;

	my $query = "
SELECT
	ser.server_name, hos.host_name, hos.host_uuid
FROM
	public.servers AS ser
JOIN
	public.hosts AS hos
ON
	ser.server_host_uuid = hos.host_uuid
WHERE
	server_uuid = ".$anvil->Database->quote($server_uuid)."
;";
	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	if ($count == 1)
	{
		my $row = $results->[0];

		$server_info = {};
		$server_info->{server_name} = $row->[0];
		$server_info->{host_name}   = $row->[1];
		$server_info->{host_uuid}   = $row->[2];

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $server_info });
	}

	return $server_info;
}

sub get_vnc_info
{
	my $parameters  = shift;
	my $host_name   = $parameters->{host_name};
	my $port_base   = $parameters->{port_base} // 5900;
	my $server_name = $parameters->{server_name};
	my $server_uuid = $parameters->{server_uuid};

	# Requires root to access VM information.
	my $shell_call = "virsh vncdisplay ".$server_name;
	my $vnc_info;

	my ($shell_output, $shell_error, $shell_return_code) = call({
		host_name   => $host_name,
		remote_user => "root",
		shell_call  => $shell_call
	});

	return if ($shell_return_code != 0);

	my ($port_offset) = $shell_output =~ /:(\d+)$/;

	$vnc_info         = { host_name => $host_name };
	$vnc_info->{port} = $port_base + int($port_offset);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		port_offset => $port_offset,
		vnc_port    => $vnc_info->{port}
	} });

	return $vnc_info;
}

sub get_available_port
{
	my $parameters    = shift;
	my $start_port    = $parameters->{start_port};
	my $host_name     = $parameters->{host_name};
	my $step_operator = ((defined $parameters->{step_operator}) and ($parameters->{step_operator} =~ /^[+-]$/)) ? $parameters->{step_operator} : "+";
	my $step_size     = (
		(defined $parameters->{step_size})
		and ($parameters->{step_size} =~ /^\d+$/)
		and ($parameters->{step_size} > 0)
	) ? $parameters->{step_size} : 1;

	my $available_port;

	my $shell_call = "ss_output=\$(ss --all --tcp --numeric) && port=".$start_port." && while egrep -q \":\${port}[[:space:]]+[^[:space:]]+\" <<<\$ss_output; do (( port ".$step_operator."= ".$step_size." )); done && echo \$port";

	my ($shell_output, $shell_error, $shell_return_code) = call({ host_name => $host_name, shell_call => $shell_call });

	if ($shell_return_code == 0)
	{
		$available_port = $shell_output;
	}

	return $available_port;
}

sub is_websockify_process
{
	my $parameters = shift;
	my $host_name  = $parameters->{host_name};
	my $ws_pid     = $parameters->{ws_pid};
	my $shell_call = "ps -e -o command -h -p ".$ws_pid;

	my ($shell_output, $shell_error, $shell_return_code) = call({ host_name  => $host_name, shell_call => $shell_call });

	return $shell_output =~ /websockify/ ? 1 : 0;
}

sub is_ssh_process
{
	my $parameters     = shift;
	my $host_name      = $parameters->{host_name};
	my $ssh_tunnel_pid = $parameters->{ssh_tunnel_pid};

	my $shell_call = "ps -e -o command -h -p ".$ssh_tunnel_pid;

	my ($shell_output) = call({ host_name => $host_name, shell_call => $shell_call });

	return $shell_output =~ /striker-open-ssh-tunnel/ ? 1 : 0;
}

sub is_websockify_exists
{
	my $parameters      = shift;
	my $server_uuid     = $parameters->{server_uuid};
	my $host_uuid       = $parameters->{host_uuid};
	my $ws_host_uuid    = $parameters->{ws_host_uuid};
	my $server_vnc_port = $parameters->{server_vnc_port};

	my $query = "
SELECT
	vnc.server_vnc_port, hos.host_name, vnc.ws_host_uuid, vnc.ws_pid, vnc.ws_source_port, vnc.ssh_tunnel_host_uuid
FROM
	public.vnc_pipes AS vnc
JOIN
	public.hosts AS hos
ON
	vnc.ws_host_uuid = hos.host_uuid
WHERE
	vnc.server_uuid = ".$anvil->Database->quote($server_uuid)."
;";

	my $results        = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $ws_exists_info = { exists_code => 0 };

	foreach my $row (@{$results})
	{
		my $server_vnc_port_in_record = $row->[0];
		my $ws_host_name              = $row->[1];
		my $ws_host_uuid_in_record    = $row->[2];
		my $ws_pid                    = $row->[3];
		my $ws_source_port            = $row->[4];
		my $ssh_tunnel_host_uuid      = $row->[5];
		my $clean_up_parameters       = { host_name => $ws_host_name, ws_pid => $ws_pid };

		if ($ws_host_uuid ne $ws_host_uuid_in_record)
		{
			# VNC server host mismatch; try to stop the recorded instance.
			# Likely happens after a server migration.
			stop_websockify($clean_up_parameters);

			# No need to preserve the websockify source port in
			# this case because the tunnel will need to be replaced
			# as well.
			$ws_exists_info->{ws_source_port} = undef();
			$ws_exists_info->{exists_code}    = 1;
		}
		elsif ($server_vnc_port != $server_vnc_port_in_record)
		{
			# VNC server port mismatch; try to stop the recorded instance.
			stop_websockify($clean_up_parameters);

			if (not exists $ws_exists_info->{ws_source_port})
			{
				$ws_exists_info->{ws_source_port} = $ws_source_port;
			}

			$ws_exists_info->{exists_code} = 1;
		}
		elsif (not is_websockify_process($clean_up_parameters))
		{
			if (not exists $ws_exists_info->{ws_source_port})
			{
				$ws_exists_info->{ws_source_port} = $ws_source_port;
			}

			# The recorded instance died.
			$ws_exists_info->{exists_code} = 1;
		}
		else
		{
			# Found one websockify instance that passed all tests.
			$ws_exists_info->{ws_pid}         = $ws_pid;
			$ws_exists_info->{ws_source_port} = $ws_source_port;
			# Code 2: the websockify instance is not recorded for the pipe made from the current host, do update only.
			# Code 3: the websockify instance is recorded for the pipe made from the current host, do nothing.
			$ws_exists_info->{exists_code}    = $host_uuid eq $ssh_tunnel_host_uuid ? 3 : 2;
			# Don't continue the loop because all pipes should align to this verified instance.
			last;
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ws_exists_info });

	return $ws_exists_info;
}

sub is_ssh_tunnel_exists
{
	my $parameters           = shift;
	my $server_uuid          = $parameters->{server_uuid};
	my $ssh_tunnel_host_uuid = $parameters->{ssh_tunnel_host_uuid};
	my $ws_host_uuid         = $parameters->{ws_host_uuid};
	my $ws_source_port       = $parameters->{ws_source_port};

	my $query = "
SELECT
	ws_host_uuid, ws_source_port, ssh_tunnel_pid, ssh_tunnel_forward_port
FROM
	public.vnc_pipes
WHERE
	server_uuid = ".$anvil->Database->quote($server_uuid)."
AND
	ssh_tunnel_host_uuid = ".$anvil->Database->quote($ssh_tunnel_host_uuid)."
;";

	my $results                = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count                  = @{$results};
	my $ssh_tunnel_exists_info = { exists_code => 0 };

	if ($count == 1)
	{
		my $row                      = $results->[0];
		my $ws_host_uuid_in_record   = $row->[0];
		my $ws_source_port_in_record = $row->[1];
		my $ssh_tunnel_pid           = $row->[2];
		my $ssh_tunnel_forward_port  = $row->[3];
		my $clean_up_parameters      = { ssh_tunnel_pid => $ssh_tunnel_pid };

		$ssh_tunnel_exists_info->{ssh_tunnel_pid}          = $ssh_tunnel_pid;
		$ssh_tunnel_exists_info->{ssh_tunnel_forward_port} = $ssh_tunnel_forward_port;
		$ssh_tunnel_exists_info->{exists_code}             = 1;

		if ($ws_host_uuid ne $ws_host_uuid_in_record)
		{
			# Websockify host mismatch; try to stop the recorded instance.
			# Likely happens after a server migration.
			stop_ssh_tunnel($clean_up_parameters);

			# No need to preserve the SSH tunnel forward port in
			# this case because the websockify instance will need
			# to be replaced as well.
			delete $ssh_tunnel_exists_info->{ssh_tunnel_forward_port};

			return $ssh_tunnel_exists_info;
		}

		if ($ws_source_port != $ws_source_port_in_record)
		{
			# Websockify source port mismatch; try to stop the recorded instance.
			stop_ssh_tunnel($clean_up_parameters);

			return $ssh_tunnel_exists_info;
		}

		if (not is_ssh_process($clean_up_parameters))
		{
			# The recorded tunnel died.
			return $ssh_tunnel_exists_info;
		}

		# Passed all tests; tunnel considered exists.
		$ssh_tunnel_exists_info->{exists_code} = 2;
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ssh_tunnel_exists_info });

	return $ssh_tunnel_exists_info;
}

sub is_websockify_in_use_by_others
{
	my $parameters = shift;
	my $ws_pid     = $parameters->{ws_pid};

	my $query = "SELECT COUNT(*) FROM public.vnc_pipes WHERE ws_pid = ".$anvil->Database->quote($ws_pid).";";

	my $count = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ })->[0]->[0];

	return $count > 1 ? 1 : 0;
}

sub is_remote_host_name
{
	my $host_name = shift;

	return ((defined $host_name) and ($host_name ne $anvil->data->{sys}{host_name})) ? 1 : 0;
}

sub start_websockify
{
	my $parameters   = shift;
	my $server_uuid  = $parameters->{server_uuid};
	my $host_uuid    = $parameters->{host_uuid};
	my $ws_host_name = $parameters->{ws_host_name};
	my $ws_host_uuid = $parameters->{ws_host_uuid};
	my $target_port  = $parameters->{target_port};
	my $source_port  = $parameters->{source_port};
	my $ws_info;

	my $ws_exists_info = is_websockify_exists({
		server_uuid     => $server_uuid,
		host_uuid       => $host_uuid,
		ws_host_uuid    => $ws_host_uuid,
		server_vnc_port => $target_port
	});

	if ($ws_exists_info->{exists_code} =~ /^[23]$/)
	{
		$ws_info                = {};
		$ws_info->{pid}         = $ws_exists_info->{ws_pid};
		$ws_info->{source_port} = $ws_exists_info->{ws_source_port};

		if ($ws_exists_info->{exists_code} == 2)
		{
			$ws_info->{is_update} = 1;
		}
	}
	else
	{
		if (not defined $source_port)
		{
			if (defined $ws_exists_info->{ws_source_port})
			{
				$source_port = $ws_exists_info->{ws_source_port};
			}
			else
			{
				my $source_port_base = 10000;

				$source_port = $source_port_base + $target_port;
			}
		}

		$source_port = get_available_port({ start_port => $source_port, host_name => $ws_host_name });

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
			source_port => $source_port
		} });

		return if (not defined $source_port);

		my $shell_call = "websockify ".$source_port." :".$target_port." &>/dev/null & echo pid:\$!";

		my ($shell_output, $shell_error, $shell_return_code) = call({
			host_name   => $ws_host_name,
			remote_user => "admin",
			shell_call  => $shell_call
		});

		return if ($shell_return_code != 0);

		my ($ws_pid) = $shell_output =~ /pid:(\d+)$/;

		$ws_info                = {};
		$ws_info->{pid}         = $ws_pid;
		$ws_info->{source_port} = $source_port;

		if ($ws_exists_info->{exists_code} == 1)
		{
			$ws_info->{is_update} = 1;
		}
		else
		{
			$ws_info->{is_new} = 1;
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ws_info });

	return $ws_info;
}

sub stop_websockify
{
	my $parameters = shift;
	my $host_name  = $parameters->{host_name};
	my $ws_pid     = $parameters->{ws_pid};

	return if (not is_websockify_process($parameters));

	my $shell_call             = "kill ".$ws_pid;
	my $call_parameters = { host_name  => $host_name, shell_call => $shell_call };

	my ($shell_output, $shell_error, $shell_return_code) = call($call_parameters);

	sleep(2);

	return if (not is_websockify_process($parameters));

	$call_parameters->{shell_call} = $shell_call =~ s/kill/kill -9/;

	($shell_output, $shell_error, $shell_return_code) = $anvil->Remote->call($call_parameters);
}

sub start_ssh_tunnel
{
	my $parameters              = shift;
	my $server_uuid             = $parameters->{server_uuid};
	my $host_name               = $parameters->{host_name};
	my $host_uuid               = $parameters->{host_uuid};
	my $ws_host_name            = $parameters->{ws_host_name};
	my $ws_host_uuid            = $parameters->{ws_host_uuid};
	my $ws_source_port          = $parameters->{ws_source_port};
	my $ssh_tunnel_forward_port = $parameters->{ssh_tunnel_forward_port};
	my $ssh_tunnel_info;

	my $ssh_tunnel_exists_info = is_ssh_tunnel_exists({
		server_uuid          => $server_uuid,
		ssh_tunnel_host_uuid => $host_uuid,
		ws_host_uuid         => $ws_host_uuid,
		ws_source_port       => $ws_source_port
	});

	if ($ssh_tunnel_exists_info->{exists_code} == 2)
	{
		$ssh_tunnel_info                 = {};
		$ssh_tunnel_info->{pid}          = $ssh_tunnel_exists_info->{ssh_tunnel_pid};
		$ssh_tunnel_info->{forward_port} = $ssh_tunnel_exists_info->{ssh_tunnel_forward_port};
	}
	else
	{
		if (not defined $ssh_tunnel_forward_port)
		{
			if (defined $ssh_tunnel_exists_info->{ssh_tunnel_forward_port})
			{
				$ssh_tunnel_forward_port = $ssh_tunnel_exists_info->{ssh_tunnel_forward_port};
			}
			else
			{
				$ssh_tunnel_forward_port = $ws_source_port;
			}
		}

		$ssh_tunnel_forward_port = get_available_port({ start_port => $ssh_tunnel_forward_port });

		$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
			ssh_tunnel_forward_port => $ssh_tunnel_forward_port
		} });

		if (not defined $ssh_tunnel_forward_port)
		{
			return;
		}

		my $shell_call = $anvil->data->{path}{exe}{'striker-open-ssh-tunnel'}
			." --remote-user admin --target ".$ws_host_name
			." --forward-local-port ".$ssh_tunnel_forward_port
			." --forward-remote-port ".$ws_source_port
			." &>/dev/null & echo pid:\$!";

		my ($shell_output, $shell_error, $shell_return_code) = call({ host_name => $host_name, shell_call => $shell_call });

		if ($shell_return_code == 0)
		{
			my ($ssh_tunnel_pid) = $shell_output =~ /pid:(\d+)$/;

			$ssh_tunnel_info                 = {};
			$ssh_tunnel_info->{pid}          = $ssh_tunnel_pid;
			$ssh_tunnel_info->{forward_port} = $ssh_tunnel_forward_port;

			if ($ssh_tunnel_exists_info->{exists_code} == 1)
			{
				$ssh_tunnel_info->{is_update} = 1;
			}
			else
			{
				$ssh_tunnel_info->{is_new} = 1;
			}
		}
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ssh_tunnel_info });

	return $ssh_tunnel_info;
}

sub stop_ssh_tunnel
{
	my $parameters     = shift;
	my $host_name      = $parameters->{host_name};
	my $ssh_tunnel_pid = $parameters->{ssh_tunnel_pid};

	return if (not is_ssh_process($parameters));

	my $shell_call      = "kill ".$ssh_tunnel_pid;
	my $call_parameters = { host_name => $host_name, shell_call => $shell_call };

	my ($shell_output, $shell_error, $shell_return_code) = call($call_parameters);

	sleep(2);

	return if (not is_ssh_process($parameters));

	$call_parameters->{shell_call} = $shell_call =~ s/kill/kill -9/;

	($shell_output, $shell_error, $shell_return_code) = call($call_parameters);
}

sub create_vnc_pipes_table
{
	my $query = "
CREATE TABLE IF NOT EXISTS public.vnc_pipes (
	uuid			uuid				not null	primary key,
	server_uuid		uuid				not null,
	server_vnc_port		numeric,
	ws_host_uuid		uuid,
	ws_pid			numeric,
	ws_source_port		numeric,
	ssh_tunnel_host_uuid	uuid,
	ssh_tunnel_pid		numeric,
	ssh_tunnel_forward_port	numeric,
	modified_date		timestamp with time zone	not null,
	unique(server_uuid)
);";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });
}

sub drop_vnc_pipes_table
{
	my $query = "DROP TABLE IF EXISTS public.vnc_pipes;";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });
}

sub insert_or_update_vnc_pipe
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};

	return (1) if (not defined $server_uuid);

	my $server_vnc_port         = $parameters->{server_vnc_port};
	my $ssh_tunnel_forward_port = $parameters->{ssh_tunnel_forward_port};
	my $ssh_tunnel_host_uuid    = $parameters->{ssh_tunnel_host_uuid};
	my $ssh_tunnel_pid          = $parameters->{ssh_tunnel_pid};
	my $vnc_pipe_uuid           = $parameters->{vnc_pipe_uuid} // $anvil->Get->uuid();
	my $ws_host_uuid            = $parameters->{ws_host_uuid};
	my $ws_pid                  = $parameters->{ws_pid};
	my $ws_source_port          = $parameters->{ws_source_port};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters });

	my $vnc_pipe_mdate        = $anvil->Database->refresh_timestamp();
	my $quoted_vnc_pipe_mdate = $anvil->Database->quote($vnc_pipe_mdate);

	my $insert_columns = "";
	my $insert_values  = "";
	my $update_values  = "";

	foreach my $column_name (
		"server_vnc_port",
		"ws_host_uuid",
		"ws_pid",
		"ws_source_port",
		"ssh_tunnel_host_uuid",
		"ssh_tunnel_pid",
		"ssh_tunnel_forward_port"
	)
	{
		my $column_value = $parameters->{$column_name};

		next if (not defined $column_value);

		my $quoted_value = ($column_value eq "NULL")
			? $column_value
			: $anvil->Database->quote($column_value);

		$insert_columns .= "$column_name,\n\t";
		$insert_values  .= "$quoted_value,\n\t";
		$update_values  .= "$column_name = $quoted_value,\n\t";
	}

	my $query = "
INSERT INTO public.vnc_pipes (
	uuid,
	server_uuid,
	$insert_columns
	modified_date
) VALUES (
	".$anvil->Database->quote($vnc_pipe_uuid).",
	".$anvil->Database->quote($server_uuid).",
	$insert_values
	$quoted_vnc_pipe_mdate
) ON CONFLICT (server_uuid) DO UPDATE SET
	$update_values
	modified_date = $quoted_vnc_pipe_mdate;";

	$anvil->Database->write({ query => $query, source => $THIS_FILE, line => __LINE__ });
}

sub get_vnc_pipe
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};

	return if (not defined $server_uuid);

	my $host_uuid    = $parameters->{host_uuid}; # ssh_tunnel_host_uuid
	my $ws_host_uuid = $parameters->{ws_host_uuid};

	my $vnc_pipe_info;

	my $cond_ssht_huuid = defined $host_uuid    ? "AND ssh_tunnel_host_uuid = ".$anvil->Database->quote($host_uuid) : "";
	my $cond_ws_huuid   = defined $ws_host_uuid ? "AND ws_host_uuid = ".$anvil->Database->quote($ws_host_uuid)      : "";

	my $query = "
SELECT
	hos.host_name,
	vnc.ws_host_uuid,
	vnc.ws_pid,
	vnc.ws_source_port,
	vnc.ssh_tunnel_pid
FROM
	public.vnc_pipes AS vnc
JOIN
	public.hosts AS hos
ON
	vnc.ws_host_uuid = hos.host_uuid
WHERE
	server_uuid = ".$anvil->Database->quote($server_uuid)."
$cond_ssht_huuid
$cond_ws_huuid
;";

	my $results = $anvil->Database->query({ query => $query, source => $THIS_FILE, line => __LINE__ });
	my $count   = @{$results};

	if ($count == 1)
	{
		my $row = $results->[0];

		$vnc_pipe_info                   = {};
		$vnc_pipe_info->{host_name}      = $row->[0];
		$vnc_pipe_info->{ws_host_uuid}   = $row->[1];
		$vnc_pipe_info->{ws_pid}         = $row->[2];
		$vnc_pipe_info->{ws_source_port} = $row->[3];
		$vnc_pipe_info->{ssh_tunnel_pid} = $row->[4];
	}

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $vnc_pipe_info });

	return $vnc_pipe_info;
}

sub open_ws
{
	my $parameters  = shift;
	my $server_uuid = $parameters->{server_uuid};

	my $server_info = $parameters->{server_info} // get_server_info($parameters);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters });

	return (1, "error_0313") if (not defined $server_info);

	my $vnc_info = get_vnc_info({
		host_name   => $server_info->{host_name},
		server_name => $server_info->{server_name},
		server_uuid => $server_uuid
	});

	return (1, "error0314") if (not defined $vnc_info);

	my $ws_info = start_websockify({
		server_uuid  => $server_uuid,
		target_port  => $vnc_info->{port},
		ws_host_name => $server_info->{host_name},
		ws_host_uuid => $server_info->{host_uuid}
	});

	return (1, "error_0315") if (not defined $ws_info);

	if ($ws_info->{is_new} or $ws_info->{is_update})
	{
		insert_or_update_vnc_pipe({
			server_uuid     => $server_uuid,
			server_vnc_port => $vnc_info->{port},
			ws_host_uuid    => $server_info->{host_uuid},
			ws_pid          => $ws_info->{pid},
			ws_source_port  => $ws_info->{source_port}
		});
	}

	return (0, $ws_info);
}

sub close_ws
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $vnc_pipe_info = $parameters->{vnc_pipe_info} // get_vnc_pipe({ server_uuid => $server_uuid, ws_host_uuid => $host_uuid });

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	return (0) if is_websockify_in_use_by_others({ ws_pid => $vnc_pipe_info->{ws_pid} });

	stop_websockify({ host_name => $vnc_pipe_info->{host_name}, ws_pid => $vnc_pipe_info->{ws_pid} });

	insert_or_update_vnc_pipe({
		server_uuid     => $server_uuid,
		server_vnc_port => "NULL",
		ws_host_uuid    => "NULL",
		ws_pid          => "NULL",
		ws_source_port  => "NULL"
	});

	return (0);
}

sub open_st
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $server_info = $parameters->{server_info} // get_server_info($parameters);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters });

	return (1, "error_0313") if (not defined $server_info);

	my $vnc_pipe_info = get_vnc_pipe({ server_uuid => $server_uuid, ws_host_uuid => $server_info->{host_uuid} });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	my $ssh_tunnel_info = start_ssh_tunnel({
		server_uuid    => $server_uuid,
		host_uuid      => $host_uuid,
		ws_host_name   => $vnc_pipe_info->{host_name},
		ws_host_uuid   => $vnc_pipe_info->{ws_host_uuid},
		ws_source_port => $vnc_pipe_info->{ws_source_port}
	});

	return (1, "error_0316") if (not defined $ssh_tunnel_info);

	if ($ssh_tunnel_info->{is_new} or $ssh_tunnel_info->{is_update})
	{
		insert_or_update_vnc_pipe({
			server_uuid             => $server_uuid,
			ssh_tunnel_host_uuid    => $host_uuid,
			ssh_tunnel_pid          => $ssh_tunnel_info->{pid},
			ssh_tunnel_forward_port => $ssh_tunnel_info->{forward_port}
		});
	}

	return (0, $ssh_tunnel_info);
}

sub close_st
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $vnc_pipe_info = $parameters->{vnc_pipe_info} // get_vnc_pipe($parameters);

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $parameters });

	return (1, "error_0317") if (not defined $vnc_pipe_info);

	stop_ssh_tunnel({ ssh_tunnel_pid => $vnc_pipe_info->{ssh_tunnel_pid} });

	insert_or_update_vnc_pipe({
		server_uuid             => $server_uuid,
		ssh_tunnel_host_uuid    => "NULL",
		ssh_tunnel_pid          => "NULL",
		ssh_tunnel_forward_port => "NULL"
	});

	return (0);
}

sub handle_vnc_pipe_error
{
	my $error_key   = shift;
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	$anvil->Log->entry({ source => $THIS_FILE, line => __LINE__, level => 1, key => $error_key, variables => {
		server_uuid => $server_uuid,
		host_uuid   => $host_uuid
	} });

	$anvil->Job->update_progress({
		progress   => 100,
		message    => "$error_key,!!server_uuid!$server_uuid!!,!!host_uuid!$host_uuid!!",
		job_status => "failed"
	});
}

sub open_vnc_pipe
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $is_print    = $parameters->{print} // (not $anvil->data->{switches}{'job-uuid'});
	my $server_uuid = $parameters->{server_uuid};

	my $is_error;
	my $open_output;

	my $open_params = {
		host_uuid   => $host_uuid,
		server_info => get_server_info($parameters),
		server_uuid => $server_uuid
	};

	($is_error, $open_output) = open_ws($open_params);

	return handle_vnc_pipe_error($open_output, $open_params) if ($is_error);

	($is_error, $open_output) = open_st($open_params);

	return handle_vnc_pipe_error($open_output, $open_params) if ($is_error);

	$anvil->Job->update_progress({
		progress => 100,
		message  => "message_0260,!!operation!opening!!,!!server_uuid!".$server_uuid."!!,!!host_uuid!".$host_uuid."!!"
	});

	my $forward_port = $open_output->{forward_port} // "";

	print "protocol:ws,forward_port:$forward_port\n" if ($is_print);

	return (0, { forward_port => $forward_port });
}

sub close_vnc_pipe
{
	my $parameters  = shift;
	my $host_uuid   = $parameters->{host_uuid};
	my $server_uuid = $parameters->{server_uuid};

	my $is_error;
	my $close_output;

	my $close_params = {
		host_uuid     => $host_uuid,
		server_uuid   => $server_uuid,
		vnc_pipe_info => get_vnc_pipe($parameters)
	};

	($is_error, $close_output) = close_ws($close_params);

	return handle_vnc_pipe_error($close_output, $close_params) if ($is_error);

	($is_error, $close_output) = close_st($close_params);

	return handle_vnc_pipe_error($close_output, $close_params) if ($is_error);

	$anvil->Job->update_progress({
		progress => 100,
		message  => "message_0260,!!operation!closing!!,!!server_uuid!".$server_uuid."!!,!!host_uuid!".$host_uuid."!!"
	});
}

$anvil->Get->switches;

$anvil->Database->connect;
$anvil->Log->entry({ source => $THIS_FILE, line => __LINE__, level => 2, secure => 0, key => "log_0132" });
if (not $anvil->data->{sys}{database}{connections})
{
	# No databases, exit.
	$anvil->Log->entry({ source => $THIS_FILE, line => __LINE__, level => 0, 'print' => 1, priority => "err", key => "error_0003" });
	$anvil->nice_exit({ exit_code => 1 });
}

# Try to get a job UUID if not given.
if (not $anvil->data->{switches}{'job-uuid'})
{
	$anvil->data->{switches}{'job-uuid'} = $anvil->Job->get_job_uuid({ program => $THIS_FILE });
	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
		"switches::job-uuid" => $anvil->data->{switches}{'job-uuid'}
	} });
}

# Handle this script as a job when job UUID is provided.
if ($anvil->data->{switches}{'job-uuid'})
{
	$anvil->Job->clear();
	$anvil->Job->get_job_details();
	$anvil->Job->update_progress({
		progress         => 1,
		job_picked_up_by => $$,
		job_picked_up_at => time,
		message          => "message_0259"
	});

	foreach my $line (split/\n/, $anvil->data->{jobs}{job_data})
	{
		if ($line =~ /server-uuid=(.*?)$/)
		{
			$anvil->data->{switches}{'server-uuid'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::server-uuid' => $anvil->data->{switches}{'server-uuid'}
			} });
		}

		if ($line =~ /open=(.*?)$/)
		{
			$anvil->data->{switches}{'open'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::open' => $anvil->data->{switches}{'open'}
			} });
		}

		if ($line =~ /drop-table=(.*?)$/)
		{
			$anvil->data->{switches}{'drop-table'} = $1;
			$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
				'switches::drop-table' => $anvil->data->{switches}{'drop-table'}
			} });
		}
	}
}

$anvil->Database->get_hosts();
$anvil->Database->get_anvils();

my $component     = $anvil->data->{switches}{'component'} // "all";
my $is_drop_table = $anvil->data->{switches}{'drop-table'};
my $is_open       = $anvil->data->{switches}{'open'};
my $server_uuid   = $anvil->data->{switches}{'server-uuid'};

$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => {
	component     => $component,
	is_open       => $is_open,
	is_drop_table => $is_drop_table,
	server_uuid   => $server_uuid
} });

my $map_to_operation = {
	all => { close => \&close_vnc_pipe, open => \&open_vnc_pipe },
	st  => { close => \&close_st, open => \&open_st },
	ws  => { close => \&close_ws, open => \&open_ws },
};

if ($server_uuid)
{
	create_vnc_pipes_table();

	my $ops = $map_to_operation->{$component};

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => $ops });

	$anvil->nice_exit({ exit_code => 1 }) if (not defined $ops);

	my $op = ($is_open) ? "open" : "close";

	$anvil->Log->variables({ source => $THIS_FILE, line => __LINE__, level => 2, list => { operation => $op } });

	my ($is_error) = $ops->{$op}({
		server_uuid => $server_uuid,
		host_uuid   => $anvil->data->{sys}{host_uuid}
	});

	$anvil->nice_exit({ exit_code => 2 }) if ($is_error);
}
elsif ($is_drop_table)
{
	drop_vnc_pipes_table();

	$anvil->Job->update_progress({ progress => 100, message => "message_0261" });
}
else
{
	$anvil->Job->update_progress({ progress => 100, message => "message_0262" });

	$anvil->nice_exit({ exit_code => 3 });
}

$anvil->nice_exit({ exit_code => 0 });
