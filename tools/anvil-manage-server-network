#!/usr/bin/perl
# 
# This program will manage server networking; Adding NICs to bridges, removing NICs, and un/plugging virtual 
# network cables.
# 
# Exit codes;
# 0 = Normal exit.
# 1 = No database connection.
# 
# TODO: 
# 
# USAGE:
# - Add a new NIC 
#   - anvil-manage-server-n --server srv01-test -add --bridge ifn1_link1 --mac aa:bb:cc:11:22:33 --model e1000e 
# - Delete a NIC 
#   - anvil-manage-server-n --server srv01-test -remove --mac aa:bb:cc:11:22:33
# - Unplug a NIC's virtual network cable
#   - anvil-manage-server-n --server srv01-test -unplug --mac aa:bb:cc:11:22:33
# - Plug in a NIC's virtual network cable
#   - anvil-manage-server-n --server srv01-test -unplug --mac aa:bb:cc:11:22:33
# 

use strict;
use warnings;
use Anvil::Tools;
require POSIX;
use Term::Cap;
use Data::Dumper;
use Sys::Virt;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# Turn off buffering so that the pinwheel will display while waiting for the SSH call(s) to complete.
$| = 1;

my $anvil = Anvil::Tools->new();

# Read switches (target ([user@]host[:port]) and the file with the target's password.
$anvil->Get->switches({list => [
	"add", 
	"bridge", 
	"mac", 
	"model", 
	"plug", 
	"remove", 
	"unplug", 
	], man => $THIS_FILE});
$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => $anvil->data->{switches}});
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "log_0115", variables => { program => $THIS_FILE }});

# Connect to the database(s). If we have no connections, we'll proceed anyway as one of the 'run_once' tasks
# is to setup the database server.
$anvil->Database->connect();
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 3, secure => 0, key => "log_0132"});
if (not $anvil->data->{sys}{database}{connections})
{
	# No databases, update the job, sleep for a bit and then exit. The daemon will pick it up and try 
	# again after we exit.
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0305"});
	sleep 10;
	$anvil->nice_exit({exit_code => 1});
}

if ($anvil->data->{switches}{'job-uuid'})
{
	load_job($anvil);
}

$anvil->Database->get_hosts({debug => 2});
$anvil->Database->get_anvils({debug => 2});
$anvil->Database->get_servers({debug => 2});
$anvil->Database->get_bridges({debug => 2});

if ($anvil->data->{switches}{add})
{
	handle_add($anvil);
}
elsif ($anvil->data->{switches}{remove})
{
	handle_remove($anvil);
}
elsif ($anvil->data->{switches}{plug})
{
	handle_plug($anvil);
}
elsif ($anvil->data->{switches}{unplug})
{
	handle_unplug($anvil);
}
else
{
	show_networks($anvil);
}





$anvil->Job->update_progress({
	progress => 100,
	message  => "job_0281", 
});
$anvil->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

sub handle_unplug
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub handle_plug
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub handle_add
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub handle_remove
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub show_networks
{
	my ($anvil) = @_;
	
	my $host_name = $anvil->Get->short_host_name();
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { host_name => $host_name }});
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvil->data->{anvils}{anvil_name}})
	{
		my $anvil_uuid        = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_uuid};
		my $anvil_description = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_description};
		my $node1_host_uuid   = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_node1_host_uuid};
		my $node2_host_uuid   = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_node2_host_uuid};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			's1:host_name'         => $anvil_name,
			's2:anvil_uuid'        => $anvil_uuid, 
			's3:anvil_description' => $anvil_description, 
			's4:node1_host_uuid'   => $node1_host_uuid." (".$anvil->Get->host_name_from_uuid({host_uuid => $node1_host_uuid}).")", 
			's5:node2_host_uuid'   => $node2_host_uuid." (".$anvil->Get->host_name_from_uuid({host_uuid => $node2_host_uuid}).")", 
		}});
		print "Anvil! Node: [".$anvil_name."] - ".$anvil_description."\n";
		
		foreach my $bridge_name (sort {$a cmp $b} keys %{$anvil->data->{bridges}{bridge_host_uuid}{$node1_host_uuid}{bridge_name}})
		{
			# Make sure this bridge is also on node 2.
			if (($node2_host_uuid) && (not $anvil->data->{bridges}{bridge_host_uuid}{$node2_host_uuid}{bridge_name}{$bridge_name}))
			{
				# Skip it.
				next;
			}
			print "- Bridge: [".$bridge_name."]\n";
		}
		
		# Now show the servers on this Anvil! node and what interfaces they have.
		foreach my $server_name (sort {$a cmp $b} keys %{$anvil->data->{servers}{anvil_uuid}{$anvil_uuid}{server_name}})
		{
			my $server_uuid           = $anvil->data->{servers}{anvil_uuid}{$anvil_uuid}{server_name}{$server_name}{server_uuid};
			my $server_definition_xml = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_definition_xml};
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				's1:server_name'           => $server_name,
				's2:server_uuid'           => $server_uuid, 
				's3:server_definition_xml' => $server_definition_xml, 
			}});
			
			# This could be delayed from what's actually happening, but we have to take the DB as
			# the source of truth.
			$anvil->Server->parse_definition({
				debug      => 2,
				host       => $host_name,
				server     => $server_name, 
				source     => "from_db",
				definition => $server_definition_xml, 
			});
			
			# Sort the interfaces by bridge
			foreach my $mac_address (sort {$a cmp $b} keys %{$anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}})
			{
				my $bridge = $anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}{$mac_address}{bridge};
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					"s1:mac_address" => $mac_address, 
					"s2:bridge"      => $bridge, 
				}});
				
				$anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address} = $mac_address;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					"servers::server_uuid::${server_uuid}::bridges::${bridge}::mac_address" => $anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address}, 
				}});
			}
			
			print "Server: [".$server_name."], uuid: [".$server_uuid."], interfaces;\n";
			foreach my $bridge (sort {$a cmp $b} keys %{$anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}})
			{
				my $mac_address      = $anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address};
				my $model            = $anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}{$mac_address}{model};
				my $ip_address       = $anvil->Network->get_ip_from_mac({mac => $mac_address});
				my $server_host_uuid = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_host_uuid};
				my $server_host_name = $server_host_uuid ? $anvil->Get->host_name_from_uuid({host_uuid => $server_host_uuid}) : "";
				my $server_state     = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_state};
				my $vnet_device      = "--";
				my $link_state       = "down";
				if (($server_state ne "shut off") && ($server_state ne "DELETED"))
				{
					$vnet_device = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_vnet_device};
					$link_state  = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_link_state};
				}
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					's01:bridge'           => $server_name,
					's02:mac_address'      => $mac_address, 
					's03:model'            => $model, 
					's04:link_state'       => $link_state, 
					's05:ip_address'       => $ip_address,
					's06:server_host_uuid' => $server_host_uuid, 
					's07:server_host_name' => $server_host_name, 
					's08:server_state'     => $server_state, 
					's09:vnet_device'      => $vnet_device, 
					's10:link_state'       => $link_state, 
				}});
				print "- Bridge: [".$bridge."], MAC: [".$mac_address."], state: [".$link_state."], model: [".$model."], last known IP: [".$ip_address."]\n";
			}
		}
		
		print "\n";
	}
	
	return(0);
}

sub load_job
{
	my ($anvil) = @_;
	
	if ($anvil->data->{switches}{'job-uuid'})
	{
		# Assume confirmation given
		$anvil->data->{switches}{confirm} = 1;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			'jobs::confirm' => $anvil->data->{jobs}{confirm}, 
		}});
	}
	else
	{
		# Not a job.
		return(0);
	}
	
	$anvil->Job->clear({
		debug    => 2,
		job_uuid => $anvil->data->{switches}{'job-uuid'}, 
	});
	$anvil->Job->get_job_details({
		debug    => 2,
		job_uuid => $anvil->data->{switches}{'job-uuid'}, 
	});
	
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		'jobs::job_data' => $anvil->data->{jobs}{job_data}, 
	}});
	foreach my $line (split/\n/, $anvil->data->{jobs}{job_data})
	{
		my ($variable, $value) =  ($line =~ /^(.*)=(.*)$/);
		   $value              =~ s/^"(.*)\"/$1/;
		   $value              =~ s/^'(.*)\'/$1/;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			's1:line'     => $line, 
			's2:variable' => $variable, 
			's3:value'    => $value, 
		}});
		
		$anvil->data->{switches}{$variable} = $value;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"switches::${variable}" => $anvil->data->{switches}{$variable}, 
		}});
	}
	
	$anvil->Job->update_progress({
		progress         => 1,
		job_picked_up_by => $$, 
		job_picked_up_at => time, 
		message          => "message_0354", 
	});
	
	return(0);
}
