#!/usr/bin/perl
# 
# This program will manage server networking; Adding NICs to bridges, removing NICs, and un/plugging virtual 
# network cables.
# 
# Exit codes;
# 0 = Normal exit.
# 1 = No database connection.
# 
# TODO: 
# 
# USAGE:
# - Add a new NIC 
#   - anvil-manage-server-n --server srv01-test -add --bridge ifn1_link1 --mac aa:bb:cc:11:22:33 --model e1000e 
# - Delete a NIC 
#   - anvil-manage-server-n --server srv01-test -remove --mac aa:bb:cc:11:22:33
# - Unplug a NIC's virtual network cable
#   - anvil-manage-server-n --server srv01-test -unplug --mac aa:bb:cc:11:22:33
# - Plug in a NIC's virtual network cable
#   - anvil-manage-server-n --server srv01-test -unplug --mac aa:bb:cc:11:22:33
# 

use strict;
use warnings;
use Anvil::Tools;
require POSIX;
use Term::Cap;
use Data::Dumper;
use Sys::Virt;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# Turn off buffering so that the pinwheel will display while waiting for the SSH call(s) to complete.
$| = 1;

my $anvil = Anvil::Tools->new();

# Read switches (target ([user@]host[:port]) and the file with the target's password.
$anvil->Get->switches({list => [
	"add", 
	"bridge", 
	"mac", 
	"model", 
	"plug", 
	"remove", 
	"server", 
	"unplug", 
	], man => $THIS_FILE});
$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => $anvil->data->{switches}});
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "log_0115", variables => { program => $THIS_FILE }});

# Connect to the database(s). If we have no connections, we'll proceed anyway as one of the 'run_once' tasks
# is to setup the database server.
$anvil->Database->connect();
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 3, secure => 0, key => "log_0132"});
if (not $anvil->data->{sys}{database}{connections})
{
	# No databases, update the job, sleep for a bit and then exit. The daemon will pick it up and try 
	# again after we exit.
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, priority => "err", key => "error_0305"});
	sleep 10;
	$anvil->nice_exit({exit_code => 1});
}

if ($anvil->data->{switches}{'job-uuid'})
{
	load_job($anvil);
}

$anvil->Database->get_hosts({debug => 2});
$anvil->Database->get_anvils({debug => 2});
$anvil->Database->get_servers({debug => 2});
$anvil->Database->get_bridges({debug => 2});

if ($anvil->data->{switches}{server})
{
	$anvil->Get->server_from_switch({server => $anvil->data->{switches}{server}});
	
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		's1:switches::server_name' => $anvil->data->{switches}{server_name},
		's2:switches::server_uuid' => $anvil->data->{switches}{server_uuid},
	}});
	
	if ((not $anvil->data->{switches}{server_name}) or ($anvil->data->{switches}{server_name} eq "!!error!!"))
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => "error_0017", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server => $anvil->data->{switches}{server}, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}

	my $server_uuid = $anvil->data->{switches}{server_uuid};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { server_uuid => $server_uuid }});
	
	$anvil->data->{switches}{anvil_uuid} = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_anvil_uuid};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		'switches::anvil_uuid' => $anvil->data->{switches}{anvil_uuid},
	}});
	
}
else
{
	$anvil->data->{switches}{server_name} = "";
	$anvil->data->{switches}{server_uuid} = "";
	$anvil->data->{switches}{anvil_uuid}  = "";
}

if ($anvil->data->{switches}{add})
{
	handle_add($anvil);
}
elsif ($anvil->data->{switches}{remove})
{
	handle_remove($anvil);
}
elsif (($anvil->data->{switches}{plug}) or ($anvil->data->{switches}{unplug}))
{
	handle_plug_unplug($anvil);
}
else
{
	show_networks($anvil);
}





$anvil->Job->update_progress({
	progress => 100,
	message  => "job_0281", 
});
$anvil->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

sub handle_plug_unplug
{
	my ($anvil) = @_;
	
	my $task         = $anvil->data->{switches}{plug} ? "plug" : "unplug";
	my $host_name    = $anvil->Get->short_host_name();
	my $server_name  = $anvil->data->{switches}{server_name};
	my $server_uuid  = $anvil->data->{switches}{server_uuid};
	my $anvil_uuid   = $anvil->data->{switches}{anvil_uuid};
	my $mac_address  = $anvil->data->{switches}{mac};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		's1:tast'        => $task,
		's2:host_name'   => $host_name, 
		's3:server_name' => $server_name,
		's4:server_uuid' => $server_uuid, 
		's5:anvil_uuid'  => $anvil_uuid, 
		's6:mac_address' => $mac_address, 
	}});
	
	if (not $server_name)
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0036" : "error_0018", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
		});
		$anvil->nice_exit({exit_code => 1});
	}
	if (not $mac_address)
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0054" : "error_0019", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server => $anvil->data->{switches}{server_name}, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	my $server_state     = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_state};
	my $server_host_uuid = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_host_uuid};
	my $server_host_name = $server_host_uuid ? $anvil->Get->host_name_from_uuid({host_uuid => $server_host_uuid}) : "";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		's1:server_name'      => $server_state,
		's2:server_host_uuid' => $server_host_uuid, 
		's3:server_host_name' => $server_host_name, 
	}});
	
	# Is the server running?
	if ($server_state ne "running")
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0074" : "error_0020", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server       => $anvil->data->{switches}{server_name}, 
				server_state => $server_state, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	# Lastly, are we the host?
	if ($server_host_uuid ne $anvil->Get->host_uuid)
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0078" : "error_0022", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server => $anvil->data->{switches}{server_name}, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	# Get the XML
	my $server_definition_xml = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_definition_xml};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { server_definition_xml => $server_definition_xml }});
	
	# This could be delayed from what's actually happening, but we have to take the DB as the source of 
	# truth.
	my $problem = $anvil->Server->parse_definition({
		debug      => 2,
		host       => $host_name,
		server     => $server_name, 
		source     => "from_db",
		definition => $server_definition_xml, 
	});
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { problem => $problem }});
	
	if ($problem)
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0080" : "error_0021", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server    => $anvil->data->{switches}{server_name}, 
				host_uuid => $server_host_uuid, 
				host_name => $server_host_name, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	# Do we know the MAC?
	if (not exists $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address})
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0119" : "error_0118", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				mac_address => $mac_address, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	# Last, is the cable already in the requested state?
	my $vnet_device         = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_vnet_device};
	my $link_state          = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_link_state};
	my $server_network_uuid = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_uuid}; 
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		's1:vnet_device'         => $vnet_device,
		's2:link_state'          => $link_state, 
		's3:server_network_uuid' => $server_network_uuid, 
	}});
	
	if (not $vnet_device)
	{
		# Can't work without a vnet device
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0121" : "error_0120", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				mac_address => $mac_address, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	if (($task eq "plug") && ($link_state eq "up"))
	{
		# Already plugged in, nothing to do.
		$anvil->Job->update_progress({
			progress   => 100,
			message    => "message_0108", 
			log_level  => 1, 
			'print'    => 1, 
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				mac_address => $mac_address, 
				vnet_device => $vnet_device, 
			},
		});
		$anvil->nice_exit({exit_code => 0});
	}
	if (($task eq "unplug") && ($link_state eq "down"))
	{
		# Already unplugged, nothing to do.
		$anvil->Job->update_progress({
			progress   => 100,
			message    => "message_0109", 
			log_level  => 1, 
			'print'    => 1, 
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				mac_address => $mac_address, 
				vnet_device => $vnet_device, 
			},
		});
		$anvil->nice_exit({exit_code => 0});
	}
	
	# Still alive? Do the things.
	my $shell_call = $anvil->data->{path}{exe}{virsh}." domif-setlink ".$server_name." --interface ".$vnet_device." ";
	if ($task eq "plug")
	{
		$shell_call .= "up";
	}
	else
	{
		$shell_call .= "down";
	}
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { shell_call => $shell_call }});
	
	$anvil->Job->update_progress({
		progress   => 50,
		message    => $task eq "plug" ? "message_0112" : "message_0113", 
		log_level  => 1, 
		'print'    => 1, 
		variables  => {
			server      => $anvil->data->{switches}{server_name}, 
			mac_address => $mac_address, 
			vnet_device => $vnet_device, 
		},
	});
	
	my ($output, $return_code) = $anvil->System->call({shell_call => $shell_call, source => $THIS_FILE, line => __LINE__});
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		output      => $output, 
		return_code => $return_code,
	}});
	if ($return_code)
	{
		$anvil->Job->update_progress({
			progress   => 100,
			message    => $task eq "plug" ? "error_0123" : "error_0122", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				shell_call  => $mac_address, 
				return_code => $return_code, 
				output      => $output, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	# Verify.
	sleep 2;
	$shell_call = $anvil->data->{path}{exe}{virsh}." domif-getlink ".$server_name." --interface ".$vnet_device." ";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { shell_call => $shell_call }});
	
	($output, $return_code) = $anvil->System->call({shell_call => $shell_call, source => $THIS_FILE, line => __LINE__});
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		output      => $output, 
		return_code => $return_code,
	}});
	
	if ($output =~ /^$vnet_device (.*)$/)
	{
		my $status = $1;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { status => $status }});
		
		if ($status eq "up")
		{
			if ($task eq "plug")
			{
				# Success! Update the database.
				$anvil->Job->update_progress({
					progress   => 100,
					message    => "message_0110", 
					log_level  => 1, 
					'print'    => 1, 
					variables  => {
						server      => $anvil->data->{switches}{server_name}, 
						mac_address => $mac_address, 
						vnet_device => $vnet_device, 
					},
				});
				
				# Update the database.
				$anvil->Database->insert_or_update_server_networks({
					debug                      => 2, 
					server_network_uuid        => $server_network_uuid, 
					server_network_server_uuid => $server_uuid, 
					server_network_mac_address => $mac_address, 
					server_network_vnet_device => $vnet_device, 
					server_network_link_state  => "up", 
				});
				$anvil->nice_exit({exit_code => 0});
			}
			else
			{
				# Failed
				$anvil->Job->update_progress({
					progress   => 100,
					message    => "error_0124", 
					job_status => "failed", 
					log_level  => 1, 
					'print'    => 1, 
					priority   => "err",
					variables  => {
						server      => $anvil->data->{switches}{server_name}, 
						mac_address => $mac_address, 
						vnet_device => $vnet_device, 
					},
				});
				$anvil->nice_exit({exit_code => 1});
			}
		}
		elsif ($status eq "down")
		{
			if ($task eq "unplug")
			{
				# Success! Update the database.
				$anvil->Job->update_progress({
					progress   => 100,
					message    => "message_0111", 
					log_level  => 1, 
					'print'    => 1, 
					variables  => {
						server      => $anvil->data->{switches}{server_name}, 
						mac_address => $mac_address, 
						vnet_device => $vnet_device, 
					},
				});
				
				# Update the database.
				$anvil->Database->insert_or_update_server_networks({
					debug                      => 2, 
					server_network_uuid        => $server_network_uuid, 
					server_network_server_uuid => $server_uuid, 
					server_network_mac_address => $mac_address, 
					server_network_vnet_device => $vnet_device, 
					server_network_link_state  => "down", 
				});
				$anvil->nice_exit({exit_code => 0});
			}
			else
			{
				# Failed
				$anvil->Job->update_progress({
					progress   => 100,
					message    => "error_0125", 
					job_status => "failed", 
					log_level  => 1, 
					'print'    => 1, 
					priority   => "err",
					variables  => {
						server      => $anvil->data->{switches}{server_name}, 
						mac_address => $mac_address, 
						vnet_device => $vnet_device, 
					},
				});
				$anvil->nice_exit({exit_code => 1});
			}
		}
		else
		{
			# Wat?
			$anvil->Job->update_progress({
				progress   => 100,
				message    => "error_0126", 
				job_status => "failed", 
				log_level  => 1, 
				'print'    => 1, 
				priority   => "err",
				variables  => {
					server      => $anvil->data->{switches}{server_name}, 
					mac_address => $mac_address, 
					vnet_device => $vnet_device, 
					status      => $status, 
				},
			});
			$anvil->nice_exit({exit_code => 1});
		}
	}
	else
	{
		# Unexpected output.
		$anvil->Job->update_progress({
			progress   => 100,
			message    => "error_0130", 
			job_status => "failed", 
			log_level  => 1, 
			'print'    => 1, 
			priority   => "err",
			variables  => {
				server      => $anvil->data->{switches}{server_name}, 
				mac_address => $mac_address, 
				vnet_device => $vnet_device, 
				return_code => $return_code, 
				output      => $output, 
			},
		});
		$anvil->nice_exit({exit_code => 1});
	}
	
	return(0);
}

sub handle_plug
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub handle_add
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub handle_remove
{
	my ($anvil) = @_;
	
	
	return(0);
}

sub show_networks
{
	my ($anvil) = @_;
	
	my $host_name = $anvil->Get->short_host_name();
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { host_name => $host_name }});
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvil->data->{anvils}{anvil_name}})
	{
		my $anvil_uuid        = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_uuid};
		my $anvil_description = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_description};
		my $node1_host_uuid   = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_node1_host_uuid};
		my $node2_host_uuid   = $anvil->data->{anvils}{anvil_name}{$anvil_name}{anvil_node2_host_uuid};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			's1:host_name'         => $anvil_name,
			's2:anvil_uuid'        => $anvil_uuid, 
			's3:anvil_description' => $anvil_description, 
			's4:node1_host_uuid'   => $node1_host_uuid." (".$anvil->Get->host_name_from_uuid({host_uuid => $node1_host_uuid}).")", 
			's5:node2_host_uuid'   => $node2_host_uuid." (".$anvil->Get->host_name_from_uuid({host_uuid => $node2_host_uuid}).")", 
		}});
		next if (($anvil->data->{switches}{anvil_uuid}) && ($anvil->data->{switches}{anvil_uuid} ne $anvil_uuid));
		print "-=] Anvil! Node: [".$anvil_name."] - ".$anvil_description."\n";
		
		foreach my $bridge_name (sort {$a cmp $b} keys %{$anvil->data->{bridges}{bridge_host_uuid}{$node1_host_uuid}{bridge_name}})
		{
			# Make sure this bridge is also on node 2.
			if (($node2_host_uuid) && (not $anvil->data->{bridges}{bridge_host_uuid}{$node2_host_uuid}{bridge_name}{$bridge_name}))
			{
				# Skip it.
				next;
			}
			print "- Bridge: [".$bridge_name."]\n";
		}
		print "\n-=] Servers on: [".$anvil_name."]\n";
		
		# Now show the servers on this Anvil! node and what interfaces they have.
		foreach my $server_name (sort {$a cmp $b} keys %{$anvil->data->{servers}{anvil_uuid}{$anvil_uuid}{server_name}})
		{
			my $server_uuid           = $anvil->data->{servers}{anvil_uuid}{$anvil_uuid}{server_name}{$server_name}{server_uuid};
			my $server_definition_xml = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_definition_xml};
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				's1:server_name'           => $server_name,
				's2:server_uuid'           => $server_uuid, 
				's3:server_definition_xml' => $server_definition_xml, 
			}});
			next if (($anvil->data->{switches}{server_uuid}) && ($server_uuid ne $anvil->data->{switches}{server_uuid}));
			
			# This could be delayed from what's actually happening, but we have to take the DB as
			# the source of truth.
			$anvil->Server->parse_definition({
				debug      => 2,
				host       => $host_name,
				server     => $server_name, 
				source     => "from_db",
				definition => $server_definition_xml, 
			});
			
			# Sort the interfaces by bridge
			foreach my $mac_address (sort {$a cmp $b} keys %{$anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}})
			{
				my $bridge = $anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}{$mac_address}{bridge};
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					"s1:mac_address" => $mac_address, 
					"s2:bridge"      => $bridge, 
				}});
				
				$anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address} = $mac_address;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					"servers::server_uuid::${server_uuid}::bridges::${bridge}::mac_address" => $anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address}, 
				}});
			}
			
			print "Server: [".$server_name."], uuid: [".$server_uuid."], interfaces;\n";
			foreach my $bridge (sort {$a cmp $b} keys %{$anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}})
			{
				my $mac_address      = $anvil->data->{servers}{server_uuid}{$server_uuid}{bridges}{$bridge}{mac_address};
				my $model            = $anvil->data->{server}{$host_name}{$server_name}{from_db}{device}{interface}{$mac_address}{model};
				my $ip_address       = $anvil->Network->get_ip_from_mac({mac => $mac_address});
				my $server_host_uuid = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_host_uuid};
				my $server_host_name = $server_host_uuid ? $anvil->Get->host_name_from_uuid({host_uuid => $server_host_uuid}) : "";
				my $server_state     = $anvil->data->{servers}{server_uuid}{$server_uuid}{server_state};
				my $vnet_device      = "--";
				my $link_state       = "down";
				if (($server_state ne "shut off") && ($server_state ne "DELETED"))
				{
					$vnet_device = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_vnet_device};
					$link_state  = $anvil->data->{servers}{server_uuid}{$server_uuid}{mac_address}{$mac_address}{server_network_link_state};
				}
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					's01:bridge'           => $server_name,
					's02:mac_address'      => $mac_address, 
					's03:model'            => $model, 
					's04:link_state'       => $link_state, 
					's05:ip_address'       => $ip_address,
					's06:server_host_uuid' => $server_host_uuid, 
					's07:server_host_name' => $server_host_name, 
					's08:server_state'     => $server_state, 
					's09:vnet_device'      => $vnet_device, 
					's10:link_state'       => $link_state, 
				}});
				print "- Bridge: [".$bridge."], MAC: [".$mac_address."], state: [".$link_state."], model: [".$model."], last known IP: [".$ip_address."]\n";
			}
		}
		
		print "\n";
	}
	
	return(0);
}

sub load_job
{
	my ($anvil) = @_;
	
	if ($anvil->data->{switches}{'job-uuid'})
	{
		# Assume confirmation given
		$anvil->data->{switches}{confirm} = 1;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			'jobs::confirm' => $anvil->data->{jobs}{confirm}, 
		}});
	}
	else
	{
		# Not a job.
		return(0);
	}
	
	$anvil->Job->clear({
		debug    => 2,
		job_uuid => $anvil->data->{switches}{'job-uuid'}, 
	});
	$anvil->Job->get_job_details({
		debug    => 2,
		job_uuid => $anvil->data->{switches}{'job-uuid'}, 
	});
	
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		'jobs::job_data' => $anvil->data->{jobs}{job_data}, 
	}});
	foreach my $line (split/\n/, $anvil->data->{jobs}{job_data})
	{
		my ($variable, $value) =  ($line =~ /^(.*)=(.*)$/);
		   $value              =~ s/^"(.*)\"/$1/;
		   $value              =~ s/^'(.*)\'/$1/;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			's1:line'     => $line, 
			's2:variable' => $variable, 
			's3:value'    => $value, 
		}});
		
		$anvil->data->{switches}{$variable} = $value;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"switches::${variable}" => $anvil->data->{switches}{$variable}, 
		}});
	}
	
	$anvil->Job->update_progress({
		progress         => 1,
		job_picked_up_by => $$, 
		job_picked_up_at => time, 
		message          => "message_0354", 
	});
	
	return(0);
}
