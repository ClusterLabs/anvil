#!/usr/bin/perl

use Device::SerialPort;
use Getopt::Long;

my @baud_rates = (115200, 9600);
my $verbose = 0;

=head2 find_serial_devices

Find a list of serial devices from ttyUSB.* and
then tests the baud speeds of each. Prints a result
if a successful device/baud rate is found.

=head2 Parameters;

=head3 list_devices

Prints a list of the devices found in ttyUSB.* instead of testing them.
=cut
sub find_serial_devices
{
  my $parameter = shift;
  my $list_devices = defined $parameter->{list_devices} ? $parameter->{list_devices} : 0;
  my $dev_path = "/dev";
  my @devices;
  my $bar = "--------------------------";

  local(*DIRECTORY);
  opendir(DIRECTORY, $dev_path);
  while(my $file = readdir(DIRECTORY))
  {
    if ($file =~ /ttyUSB.*/)
    {
      my $path = $dev_path . "/$file";
      push @devices, $path;
    }
  }

  if (!(scalar(@devices)))
  {
    print "No devices found.\n";
  }
  elsif ($list_devices)
  {
    print "Serial devices found\n$bar\n";
    print "$_\n" foreach (@devices);
  }
  else
  {
    print "Testing serial devices...\n$bar\n";
    test_serial_devices({devices => \@devices});
  }
}

=head2 test_serial_devices

Tests a list of device/baud rate combinations,
and prints the results of each successful pair.
One combination per device should be usable.

=head2 Parameters;

=head3 devices

An array of serial device paths.

=cut
sub test_serial_devices
{
  my $parameter = shift;
  my @successful_devices;
  my $devices = defined $parameter->{devices} ? $parameter->{devices} : ();

  foreach my $device (@{$devices})
  {
    foreach my $baud_rate (@baud_rates)
    {
      my $device_test = {device => $device, baud_rate => $baud_rate};
      print "Testing Device: " . $device_test->{device} . ", Baud Rate: " . $device_test->{baud_rate} . "\n" if ($verbose);
      $device_test->{output} = get_serial_output($device_test);
      if (verify_serial_device({output => $device_test->{output}}))
      {
        print "$device ($baud_rate)\n\n";
        push @successful_devices, $device_test;
        last;
      }
      sleep(2);
    }
  }

  if (!(scalar(@successful_devices)))
  {
    print "No successful serial device and baud rate combinations found.\n";
  }

  return \@successful_devices;
}

=head2 get_serial_output

Gets the output from a serial device after sending a carrage return.

=head2 Parameters;

=head3 device

A serial device path name.

=head3 baud_rate

The baud rate to test with.

=head3 port

A Device::SerialPort instance.

=head3 str_to_write

The string to write to serial. Defaults to a "\r\r".

=head3 bytes_to_read

The amount of bytes to read. Defaults to 256 bytes.

=cut
sub get_serial_output
{
  my $parameter = shift;
  my $device = defined $parameter->{device} ? $parameter->{device} : "";
  my $baud_rate = defined $parameter->{baud_rate} ? $parameter->{baud_rate} : "";
  my $port = defined $parameter->{port} ? $parameter->{port} : "";
  my $str_to_write = defined $parameter->{str_to_write} ? $parameter->{str_to_write} : "\r\r";
  my $bytes_to_read = defined $parameter->{bytes_to_read} ? $parameter->{bytes_to_read} : 256;
  my $should_close = 0;

  if (!$port)
  {
    $port = create_serial_port({device => $device, baud_rate => $baud_rate}) || return 0;
    $should_close = 1;
  }
  $port->write($str_to_write);
  $port->lookclear();
  sleep(2);
  my $output = $port->read($bytes_to_read);
  $port->close() if ($should_close);
  print(($output =~ /^\s*$/) ? "Warning: Empty Output\n" : "Output: $output\n") if ($verbose);
  return $output;
}

=head2 verify_serial_device

Tests if a device/baud rate combination has proper output.

=head2 Parameters;

=head3 output

The output from test_serial_device().

=head3 char_amount

The amount of characters in a row that need to be an actual character.

=cut
sub verify_serial_device
{
  my $parameter = shift;
  my $output = defined $parameter->{output} ? $parameter->{output} : "";
  my $char_amount = defined $parameter->{char_amount} ? $parameter->{char_amount} : 5;
  return ($output =~ /(?=.*[ -~])[ -~]{$char_amount,}.*$/);
}

=head2 create_serial_port

Creates a serial device connection using Device::SerialPort.

=head2 Parameters;

=head3 device

A serial device path name.

=head3 baud_rate

The baud rate to test with.

=cut
sub create_serial_port
{
  my $parameter = shift;
  my $device = defined $parameter->{device} ? $parameter->{device} : "";
  my $baud_rate = defined $parameter->{baud_rate} ? $parameter->{baud_rate} : "";
  my $port = new Device::SerialPort($device, 1);
  if (!$port)
  {
    print "Could not connect to serial device.\n" if ($verbose);
    return 0;
  }
  $port->baudrate($baud_rate);
  $port->parity("none");
  $port->databits(8);
  $port->stopbits(1);
  return $port;
}

=head2 perform_serial_action

Matches a serial action+output from a list, and calls a specific subroutine based on that.

Creates a serial connection with the baud rate found for a device, and closes it
when all interactions are finished.

=head2 Parameters;

=head3 device

A serial device path name.

=head3 action

An action that matches one on the list of actions.

=cut
sub perform_serial_action
{
  my $parameter = shift;
  my $device = defined $parameter->{device} ? $parameter->{device} : {};
  my $action = defined $parameter->{action} ? $parameter->{action} : {};
  my @actions = (
    { action => "configureIP", output => "User Name :", sub => \&configure_ip_apc_pdu, required_params => ["ip", "subnet", "gateway"] }
  );

  $parameter->{port} = create_serial_port({device => $device->{device}, baud_rate => $device->{baud_rate}}) || return 0;

  foreach my $action_type (@actions)
  {
    my $output_check = $action_type->{output};
    if ($action eq $action_type->{action} && $device->{output} =~ /$output_check/)
    {
      my $proper_params = 1;
      # If the command line did not have all required arguments, do not perform this action.
      foreach my $param (@{$action_type->{required_params}}) {
        $proper_params = 0 if (!exists($parameter->{$param}));
      }
      $proper_params ? $action_type->{sub}($parameter) : print "Improper parameters for serial interaction.\n";
      last;
    }
  }

  $parameter->{port}->close();
}

=head2 configure_ip_apc_pdu

A serial action that sets the ip, gateway, and subnet for an APC RackPDU.

=head2 Parameters;

=head3 ip

=head3 subnet

=head3 gateway

=cut
sub configure_ip_apc_pdu
{
  my $parameter = shift;
  my $ip = defined $parameter->{ip} ? $parameter->{ip} : "";
  my $subnet = defined $parameter->{subnet} ? $parameter->{subnet} : "";
  my $gateway = defined $parameter->{gateway} ? $parameter->{gateway} : "";
  $parameter->{to_check} = [
    { input => "apc\r", output => "Password  :" },
    { input => "apc\r", output => "------- Control Console" },
    { input => "2\r", output => "------- Network" },
    { input => "1\r", output => "------- TCP/IP", skip => { goto => 6, output => "1- System IP" } },
    { input => "1\r", output => "------- Boot Mode" },
    { input => "4\r", output => "------- TCP/IP" },
    { input => "1\r", output => "System IP :" },
    { input => "$ip\r", output => "1- System IP      : $ip" },
    { input => "2\r", output => "Subnet Mask :" },
    { input => "$subnet\r", output => "2- Subnet Mask    : $subnet" },
    { input => "3\r", output => "Default Gateway :" },
    { input => "$gateway\r", output => "3- Default Gateway: $gateway" },
    { input => "\e", output => "------- Network" },
    { input => "\e", output => "------- Control Console" },
    { input => "4\r", output => "Logging out." },
  ];
  serial_interaction($parameter);
}


=head2 serial_interaction

Interacts through a serial connection with a list of inputs and expected outputs.
Stops if any incorrect output was found.

=head2 Parameters;

=head3 port

A connected instance of Device::SerialPort.

=cut
sub serial_interaction
{
  my $parameter = shift;
  my @to_check = @{$parameter->{to_check}};
  my $port = defined $parameter->{port} ? $parameter->{port} : return 0;

  for (my $i = 0; $i < scalar(@to_check); $i++)
  {
    my $check = $to_check[$i];
    my $output = get_serial_output({port => $port, str_to_write => $check->{input}, bytes_to_read => 1024});
    my $expected = $check->{output};
    print "Input: " . $check->{input} . "\n" if ($verbose);
    print "Expected: " . $expected . "\n" if ($verbose);
    print "Output: " . $output . "\n" if ($verbose);
    # Only continue if the output matches the expected one.
    if ($output =~ /$expected/)
    {
      print "Correct output...\n" if ($verbose);
      if (exists($check->{skip}))
      {
        # If there's a skip check, see if the output matches it. If so, goto that index on the list.
        $i = ($check->{skip}->{goto} - 1) if ($output =~ $check->{skip}->{output});
        print "Skipping to $i in sequence...\n" if ($verbose);
      }
    }
    else
    {
      print "Warning: Incorrect output... Stopping.\n" if ($verbose);
      last;
    }
  }
}

my @devices;
my $device;
my $list_devices = 0;
my $action;
my $ip;
my $subnet;
my $gateway;

GetOptions(
  'device=s' => \$device,
  'list' => \$list_devices,
  'verbose' => \$verbose,
  'action=s' => \$action,
  'ip=s' => \$ip,
  'subnet=s' => \$subnet,
  'gateway=s' => \$gateway
);

if ($device)
{
  my @successful_devices = @{test_serial_devices({devices => [$device]})};
  if ($action && scalar(@successful_devices))
  {
    perform_serial_action({
      device => $successful_devices[0],
      action => $action,
      ip => $ip,
      subnet => $subnet,
      gateway => $gateway
    });
  }
}
else
{
  find_serial_devices({list_devices => $list_devices});
}
