#!/usr/bin/perl
# 
# This scans the nodes and DR host for DRBD resources and their states. 
# 
# NOTE: The data stored here is not bound to a given host. As such, only hosted VMs are processed.
# 
# Examples;
# 
# Exit codes;
# 0 = Normal exit.
# 1 = Startup failure (not running as root, no DB, bad file read, etc)
# 2 = DRBD not found or configured.
# 
# TODO: 
# - 
# 

use strict;
use warnings;
use Anvil::Tools;
use Data::Dumper;
use Text::Diff;

# Disable buffering
$| = 1;

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

my $anvil = Anvil::Tools->new({log_level => 2, log_secure => 1});
$anvil->Log->level({set => 2});
$anvil->Log->secure({set => 1});

$anvil->data->{'scan-drbd'} = {
	resource_status		=>	"/sys/kernel/debug/drbd/resources",
	config_directory	=>	"/etc/drbd.d",
	alert_sort		=>	2,
	queries                 =>	[],
};

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	# Not root
	print $anvil->Words->string({key => "error_0005"})."\n";
	$anvil->nice_exit({exit_code => 1});
}

$anvil->data->{scancore}{'scan-drbd'}{disable}         = 0;
$anvil->data->{scancore}{'scan-drbd'}{'auto-undefine'} = 1;
$anvil->data->{switches}{force}                          = 0;

$anvil->Storage->read_config();

# Read switches
$anvil->Get->switches;

# If we're disabled and '--force' wasn't used, exit.
if (($anvil->data->{scancore}{'scan-drbd'}{disable}) && (not $anvil->data->{switches}{force}))
{
	# Exit.
	$anvil->nice_exit({exit_code => 0});
}

if ($anvil->data->{switches}{purge})
{
	# This can be called when doing bulk-database purges.
	my $schema_file = $anvil->data->{path}{directories}{scan_agents}."/".$THIS_FILE."/".$THIS_FILE.".sql";
	$anvil->Database->purge_data({
		debug  => 2,
		tables => $anvil->Database->get_tables_from_schema({schema_file => $schema_file}),
	});
	$anvil->nice_exit({exit_code => 0});
}

# Handle start-up tasks
my $problem = $anvil->ScanCore->agent_startup({agent => $THIS_FILE});
if ($problem)
{
	$anvil->nice_exit({exit_code => 1});
}
$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 1, key => "scan_drbd_log_0001", variables => { program => $THIS_FILE }});

if (not gather_data($anvil))
{
	# DRBD not found or configured.
	$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, 'print' => 1, level => 0, key => "scan_drbd_error_0001"});
	$anvil->nice_exit({exit_code => 2});
}

read_last_scan($anvil);

find_changes($anvil);


# Update the database
$anvil->Database->insert_or_update_updated({updated_by => $THIS_FILE});

# Clean up and go away.
$anvil->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This reads in the last scan's data.
sub read_last_scan
{
	my ($anvil) = @_;
	
	# This is used to determine if there's an entry in scan_drbd directly.
	$anvil->data->{old}{scan_drbd_uuid} = "";
	
	# This calls up the entry for this host. There will only be one.
	my $query = "
SELECT 
    scan_drbd_uuid, 
    scan_drbd_common_xml, 
    scan_drbd_flush_disk, 
    scan_drbd_flush_md, 
    scan_drbd_timeout, 
    scan_drbd_total_sync_speed 
FROM 
    scan_drbd 
WHERE 
    scan_drbd_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)." 
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	my $results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		results => $results, 
		count   => $count, 
	}});
	foreach my $row (@{$results})
	{
		# We've got an entry in the 'scan_drbd' table, so now we'll look for data in the node and 
		# services tables.
		my $scan_drbd_uuid = $row->[0]; 
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { scan_drbd_uuid => $scan_drbd_uuid }});
		
		# Store the old data now.
		$anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_common_xml}       = $row->[1];
		$anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_disk}       = $row->[2];
		$anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_md}         = $row->[3];
		$anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_timeout}          = $row->[4];
		$anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_total_sync_speed} = $row->[5];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::scan_drbd::scan_drbd_uuid::${scan_drbd_uuid}::scan_drbd_common_xml"       => $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_common_xml},
			"old::scan_drbd::scan_drbd_uuid::${scan_drbd_uuid}::scan_drbd_flush_disk"       => $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_disk},
			"old::scan_drbd::scan_drbd_uuid::${scan_drbd_uuid}::scan_drbd_flush_md"         => $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_md},
			"old::scan_drbd::scan_drbd_uuid::${scan_drbd_uuid}::scan_drbd_timeout"          => $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_timeout},
			"old::scan_drbd::scan_drbd_uuid::${scan_drbd_uuid}::scan_drbd_total_sync_speed" => $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_total_sync_speed},
		}});
		
		# Record the drbd_uuid in an easy to find place for later when looking for changes.
		$anvil->data->{old}{scan_drbd_uuid} = $scan_drbd_uuid;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { "old::scan_drbd_uuid" => $anvil->data->{old}{scan_drbd_uuid} }});
	}
	undef $count;
	undef $results;
	
	# Read in the RAM module data.
	$query = "
SELECT 
    scan_drbd_resource_uuid, 
    scan_drbd_resource_name, 
    scan_drbd_resource_up, 
    scan_drbd_resource_xml
FROM 
    scan_drbd_resources 
WHERE 
    scan_drbd_resource_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)." 
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	$results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
	$count   = @{$results};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		results => $results, 
		count   => $count, 
	}});
	foreach my $row (@{$results})
	{
		# We've got an entry in the 'scan_drbd_resources' table, so now we'll look for data in the node and 
		# services tables.
		my $scan_drbd_resource_uuid = $row->[0]; 
		my $scan_drbd_resource_name = $row->[1]; 
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			scan_drbd_resource_uuid => $scan_drbd_resource_uuid,
			scan_drbd_resource_name => $scan_drbd_resource_name,
		}});
		
		# Store the old data now.
		$anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_name} = $scan_drbd_resource_name;
		$anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_up}   = $row->[2];
		$anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_xml}  = $row->[3];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::scan_drbd_resource::scan_drbd_resource_uuid::${scan_drbd_resource_uuid}::scan_drbd_resource_name" => $anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_name},
			"old::scan_drbd_resource::scan_drbd_resource_uuid::${scan_drbd_resource_uuid}::scan_drbd_resource_up"   => $anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_up},
			"old::scan_drbd_resource::scan_drbd_resource_uuid::${scan_drbd_resource_uuid}::scan_drbd_resource_xml"  => $anvil->data->{old}{scan_drbd_resource}{scan_drbd_resource_uuid}{$scan_drbd_resource_uuid}{scan_drbd_resource_xml},
		}});
		
		# Record the scan_drbd_resource_uuid in an easy to find place for later when looking for changes.
		$anvil->data->{old}{resource_to_uuid}{$scan_drbd_resource_name}{uuid} = $scan_drbd_resource_uuid;
		$anvil->data->{old}{uuid_to_resource}{$scan_drbd_resource_uuid}{name} = $scan_drbd_resource_name;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::resource_to_uuid::${scan_drbd_resource_name}::uuid" => $anvil->data->{old}{resource_to_uuid}{$scan_drbd_resource_name}{uuid}, 
			"old::uuid_to_resource::${scan_drbd_resource_uuid}::name" => $anvil->data->{old}{uuid_to_resource}{$scan_drbd_resource_uuid}{name}, 
		}});
	}
	undef $count;
	undef $results;
	
	# Read in the RAM module data.
	$query = "
SELECT 
    scan_drbd_volume_uuid, 
    scan_drbd_volume_scan_drbd_resource_uuid, 
    scan_drbd_volume_number, 
    scan_drbd_volume_device_path, 
    scan_drbd_volume_device_minor, 
    scan_drbd_volume_size
FROM 
    scan_drbd_volumes 
WHERE 
    scan_drbd_volume_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)." 
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	$results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
	$count   = @{$results};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		results => $results, 
		count   => $count, 
	}});
	foreach my $row (@{$results})
	{
		# We've got an entry in the 'scan_drbd_volumes' table, so now we'll look for data in the node and 
		# services tables.
		my $scan_drbd_volume_uuid                    = $row->[0]; 
		my $scan_drbd_volume_scan_drbd_resource_uuid = $row->[1]; 
		my $scan_drbd_volume_number                  = $row->[2];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			scan_drbd_volume_uuid                    => $scan_drbd_volume_uuid,
			scan_drbd_volume_scan_drbd_resource_uuid => $scan_drbd_volume_scan_drbd_resource_uuid,
			scan_drbd_volume_number                  => $scan_drbd_volume_number, 
		}});
		
		# Store the old data now.
		$anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_device_path}  = $row->[3];
		$anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_device_minor} = $row->[4];
		$anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_size}         = $row->[5];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::scan_drbd_volume::scan_drbd_volume_uuid::${scan_drbd_volume_uuid}::scan_drbd_volume_device_path"  => $anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_device_path},
			"old::scan_drbd_volume::scan_drbd_volume_uuid::${scan_drbd_volume_uuid}::scan_drbd_volume_device_minor" => $anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_device_minor},
			"old::scan_drbd_volume::scan_drbd_volume_uuid::${scan_drbd_volume_uuid}::scan_drbd_volume_xml"          => $anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_size}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{old}{scan_drbd_volume}{scan_drbd_volume_uuid}{$scan_drbd_volume_uuid}{scan_drbd_volume_size}}).")",
		}});
		
		# Record the scan_drbd_volume_uuid in an easy to find place for later when looking for changes.
		$anvil->data->{old}{resource_to_uuid}{$scan_drbd_resource_name}{volume}{$scan_drbd_volume_number}{uuid}                = $scan_drbd_volume_uuid;
		$anvil->data->{old}{uuid_to_volume}{$scan_drbd_volume_scan_drbd_resource_uuid}{volume}{$scan_drbd_volume_uuid}{number} = $scan_drbd_volume_number;
		$anvil->data->{old}{volume_to_uuid}{$scan_drbd_volume_uuid}{number}                                                    = $scan_drbd_volume_number;
		$anvil->data->{old}{volume_to_uuid}{$scan_drbd_volume_uuid}{on_resource}                                               = $scan_drbd_volume_scan_drbd_resource_uuid;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::resource_to_uuid::${scan_drbd_resource_name}::volume::${scan_drbd_volume_number}::uuid"                => $anvil->data->{old}{resource_to_uuid}{$scan_drbd_resource_name}{volume}{$scan_drbd_volume_number}{uuid}, 
			"old::uuid_to_volume::${scan_drbd_volume_scan_drbd_resource_uuid}::volume::${scan_drbd_volume_uuid}::number" => $anvil->data->{old}{uuid_to_volume}{$scan_drbd_volume_scan_drbd_resource_uuid}{volume}{$scan_drbd_volume_uuid}{number}, 
			"old::volume_to_uuid::${scan_drbd_volume_uuid}::number"                                                      => $anvil->data->{old}{volume_to_uuid}{$scan_drbd_volume_uuid}{number}, 
			"old::volume_to_uuid::${scan_drbd_volume_uuid}::on_resource"                                                 => $anvil->data->{old}{volume_to_uuid}{$scan_drbd_volume_uuid}{on_resource}, 
		}});
	}
	undef $count;
	undef $results;
	
	# Read in the RAM module data.
	$query = "
SELECT 
    scan_drbd_peer_uuid, 
    scan_drbd_peer_scan_drbd_volume_uuid, 
    scan_drbd_peer_host_name, 
    scan_drbd_peer_connection_state, 
    scan_drbd_peer_local_disk_state, 
    scan_drbd_peer_disk_state, 
    scan_drbd_peer_local_role, 
    scan_drbd_peer_role, 
    scan_drbd_peer_out_of_sync_size, 
    scan_drbd_peer_replication_speed, 
    scan_drbd_peer_estimated_time_to_sync, 
    scan_drbd_peer_ip_address, 
    scan_drbd_peer_tcp_port, 
    scan_drbd_peer_protocol, 
    scan_drbd_peer_fencing 
FROM 
    scan_drbd_peers 
WHERE 
    scan_drbd_peer_host_uuid = ".$anvil->Database->quote($anvil->Get->host_uuid)." 
;";
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
	
	$results = $anvil->Database->query({query => $query, source => $THIS_FILE, line => __LINE__});
	$count   = @{$results};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		results => $results, 
		count   => $count, 
	}});
	foreach my $row (@{$results})
	{
		# We've got an entry in the 'scan_drbd_peers' table, so now we'll look for data in the node and 
		# services tables.
		my $scan_drbd_peer_uuid                  = $row->[0]; 
		my $scan_drbd_peer_scan_drbd_volume_uuid = $row->[1]; 
		my $scan_drbd_peer_host_name             = $row->[2];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			scan_drbd_peer_uuid                  => $scan_drbd_peer_uuid,
			scan_drbd_peer_scan_drbd_volume_uuid => $scan_drbd_peer_scan_drbd_volume_uuid,
			scan_drbd_peer_host_name             => $scan_drbd_peer_host_name, 
		}});
		
		# Store the old data now.
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_scan_drbd_volume_uuid}  = $scan_drbd_peer_scan_drbd_volume_uuid;
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_host_name}              = $scan_drbd_peer_host_name;
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_connection_state}       = $row->[3];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_local_disk_state}       = $row->[4];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_disk_state}             = $row->[5];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_local_role}             = $row->[6];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_role}                   = $row->[7];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_out_of_sync_size}       = $row->[8];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_replication_speed}      = $row->[9];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_estimated_time_to_sync} = $row->[10];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_ip_address}             = $row->[11];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_tcp_port}               = $row->[12];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_protocol}               = $row->[13];
		$anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_fencing}                = $row->[14];
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_scan_drbd_volume_uuid"  => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_scan_drbd_volume_uuid},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_host_name"              => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_host_name},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_connection_state"       => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_connection_state},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_local_disk_state"       => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_local_disk_state},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_role"                   => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_role},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_disk_state"             => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_disk_state},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_local_role"             => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_local_role},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_role"                   => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_role},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_out_of_sync_size"       => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_out_of_sync_size}." ("..")",
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_replication_speed"      => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_replication_speed}." ("..")",
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_estimated_time_to_sync" => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_estimated_time_to_sync}." ("..")",
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_ip_address"             => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_ip_address},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_tcp_port"               => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_tcp_port},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_protocol"               => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_protocol},
			"old::scan_drbd_peer::scan_drbd_peer_uuid::${scan_drbd_peer_uuid}::scan_drbd_peer_fencing"                => $anvil->data->{old}{scan_drbd_peer}{scan_drbd_peer_uuid}{$scan_drbd_peer_uuid}{scan_drbd_peer_fencing},
		}});
		
		# Record the scan_drbd_peer_uuid in an easy to find place for later when looking for changes.
		my $volume_number    = $anvil->data->{old}{volume_to_uuid}{$scan_drbd_peer_scan_drbd_volume_uuid}{number};
		my $on_resource_uuid = $anvil->data->{old}{volume_to_uuid}{$scan_drbd_peer_scan_drbd_volume_uuid}{on_resource};
		my $on_resource_name = $anvil->data->{old}{uuid_to_resource}{$scan_drbd_resource_uuid}{name};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			volume_number    => $volume_number,
			on_resource_uuid => $on_resource_uuid, 
			on_resource_name => $on_resource_name, 
		}});
		
		$anvil->data->{old}{resource_to_uuid}{$on_resource_name}{volume}{$volume_number}{peer}{$scan_drbd_peer_host_name}{uuid} = $scan_drbd_peer_uuid;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"old::resource_to_uuid::${scan_drbd_resource_name}::volume::${volume_number}::peer::${scan_drbd_peer_host_name}::uuid" => $anvil->data->{old}{resource_to_uuid}{$scan_drbd_resource_name}{volume}{$volume_number}{peer}{$scan_drbd_peer_host_name}{uuid}, 
		}});
	}
	
	return(0);
}

sub process_drbd
{
	my ($anvil) = @_;
	
	if ($anvil->data->{old}{scan_drbd_uuid})
	{
		# Existing, any changes?
		my $scan_drbd_uuid                 = $anvil->data->{old}{scan_drbd_uuid};
		my $new_scan_drbd_common_xml       = $anvil->data->{new}{scan_drbd}{scan_drbd_common_xml};
		my $old_scan_drbd_common_xml       = $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_common_xml};
		my $scan_drbd_common_xml_diff      = diff \$old_scan_drbd_common_xml, \$new_scan_drbd_common_xml, { STYLE => 'Unified' },
		my $new_scan_drbd_flush_disk       = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk};
		my $old_scan_drbd_flush_disk       = $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_disk};
		my $new_scan_drbd_flush_md         = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_md};
		my $old_scan_drbd_flush_md         = $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_flush_md};
		my $new_scan_drbd_timeout          = $anvil->data->{new}{scan_drbd}{scan_drbd_timeout};
		my $old_scan_drbd_timeout          = $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_timeout};
		my $new_scan_drbd_total_sync_speed = $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed};
		my $old_scan_drbd_total_sync_speed = $anvil->data->{old}{scan_drbd}{scan_drbd_uuid}{$scan_drbd_uuid}{scan_drbd_total_sync_speed};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
			"s1:new_scan_drbd_common_xml" => $new_scan_drbd_common_xml, 
			"s2:old_scan_drbd_common_xml" => $old_scan_drbd_common_xml, 
		}});
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
			"s01:scan_drbd_uuid"                 => $new_scan_drbd_flush_disk, 
			"s02:scan_drbd_common_xml_diff"      => $new_scan_drbd_flush_md, 
			"s03:new_scan_drbd_flush_disk"       => $new_scan_drbd_flush_disk, 
			"s04:old_scan_drbd_flush_disk"       => $old_scan_drbd_flush_disk, 
			"s05:new_scan_drbd_flush_md"         => $new_scan_drbd_flush_md, 
			"s06:old_scan_drbd_flush_md"         => $old_scan_drbd_flush_md, 
			"s07:new_scan_drbd_timeout"          => $new_scan_drbd_timeout, 
			"s08:old_scan_drbd_timeout"          => $old_scan_drbd_timeout, 
			"s09:new_scan_drbd_total_sync_speed" => $new_scan_drbd_total_sync_speed." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_total_sync_speed})."/s)", 
			"s10:old_scan_drbd_total_sync_speed" => $old_scan_drbd_total_sync_speed." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $old_scan_drbd_total_sync_speed})."/s)", 
		}});
		
		my $update = 0;
		if ($new_scan_drbd_flush_disk ne $old_scan_drbd_flush_disk)
		{
			   $update    = 1;
			my $variables = {
				old_value => $new_scan_drbd_flush_disk ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
				new_value => $old_scan_drbd_flush_disk ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
			};
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "scan_drbd_message_0002", variables => $variables});
			$anvil->Alert->register({alert_level => "notice", message => "scan_drbd_message_0002", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
			
		}
		if ($new_scan_drbd_flush_md ne $old_scan_drbd_flush_md)
		{
			   $update    = 1;
			my $variables = {
				old_value => $new_scan_drbd_flush_md ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
				new_value => $old_scan_drbd_flush_md ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
			};
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "scan_drbd_message_0003", variables => $variables});
			$anvil->Alert->register({alert_level => "notice", message => "scan_drbd_message_0003", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
			
		}
		if ($new_scan_drbd_timeout ne $old_scan_drbd_timeout)
		{
			   $update    = 1;
			my $variables = {
				old_value => $new_scan_drbd_timeout, 
				new_value => $old_scan_drbd_timeout, 
			};
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "scan_drbd_message_0004", variables => $variables});
			$anvil->Alert->register({alert_level => "notice", message => "scan_drbd_message_0004", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
			
		}
		if ($new_scan_drbd_total_sync_speed ne $old_scan_drbd_total_sync_speed)
		{
			# This changes _constantly_ during a resync, so it's info-level.
			   $update    = 1;
			my $variables = {
				old_value => $anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_total_sync_speed}), 
				new_value => $anvil->Convert->bytes_to_human_readable({'bytes' => $old_scan_drbd_total_sync_speed}), 
			};
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "scan_drbd_message_0005", variables => $variables});
			$anvil->Alert->register({alert_level => "info", message => "scan_drbd_message_0005", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
			
		}
		if ($scan_drbd_common_xml_diff)
		{
			   $update    = 1;
			my $variables = {
				difference => $scan_drbd_common_xml_diff, 
				new_config => $new_scan_drbd_common_xml, 
			};
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 2, key => "scan_drbd_message_0006", variables => $variables});
			$anvil->Alert->register({alert_level => "notice", message => "scan_drbd_message_0006", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
		}
		
		if ($update)
		{
			# UPDATE!
			my $query = "
UPDATE 
    scan_drbd 
SET
    scan_drbd_common_xml       = ".$anvil->Database->quote($new_scan_drbd_common_xml).", 
    scan_drbd_flush_disk       = ".$anvil->Database->quote($new_scan_drbd_flush_disk).", 
    scan_drbd_flush_md         = ".$anvil->Database->quote($new_scan_drbd_flush_md).", 
    scan_drbd_timeout          = ".$anvil->Database->quote($new_scan_drbd_timeout).", 
    scan_drbd_total_sync_speed = ".$anvil->Database->quote($new_scan_drbd_total_sync_speed).", 
    modified_date              = ".$anvil->Database->quote($anvil->data->{sys}{database}{timestamp})." 
WHERE 
    scan_drbd_uuid             = ".$anvil->Database->quote($scan_drbd_uuid)."
;
";
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
			$anvil->Database->write({query => $query, source => $THIS_FILE, line => __LINE__});
		}
	}
	else
	{
		# New, INSERT.
		my $scan_drbd_uuid                 = $anvil->Get->uuid();
		my $new_scan_drbd_common_xml       = $anvil->data->{new}{scan_drbd}{scan_drbd_common_xml};
		my $new_scan_drbd_flush_disk       = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk};
		my $new_scan_drbd_flush_md         = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_md};
		my $new_scan_drbd_timeout          = $anvil->data->{new}{scan_drbd}{scan_drbd_timeout};
		my $new_scan_drbd_total_sync_speed = $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed};
		my $say_scan_drbd_total_sync_speed = $anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}})."/#!string!scan_drbd_unit_0003!#";
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
			"s1:scan_drbd_uuid"                 => $scan_drbd_uuid, 
			"s2:new_scan_drbd_flush_disk"       => $new_scan_drbd_flush_disk, 
			"s3:new_scan_drbd_flush_md"         => $new_scan_drbd_flush_md, 
			"s4:new_scan_drbd_timeout"          => $new_scan_drbd_timeout, 
			"s5:new_scan_drbd_total_sync_speed" => $new_scan_drbd_total_sync_speed, 
			"s6:say_scan_drbd_total_sync_speed" => $say_scan_drbd_total_sync_speed, 
			"s7:new_scan_drbd_common_xml"       => $new_scan_drbd_common_xml, 
		}});
		
		$anvil->data->{old}{scan_drbd_uuid} = $scan_drbd_uuid;
		
		my $variables = {
			new_scan_drbd_flush_disk       => $new_scan_drbd_flush_disk ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
			new_scan_drbd_flush_md         => $new_scan_drbd_flush_md   ? "#!string!scan_drbd_unit_0001!#" : "#!string!scan_drbd_unit_0002!#", 
			new_scan_drbd_timeout          => $new_scan_drbd_timeout, 
			say_scan_drbd_total_sync_speed => $say_scan_drbd_total_sync_speed, 
			new_scan_drbd_common_xml       => $new_scan_drbd_common_xml, 
		};
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 1, key => "scan_drbd_message_0001", variables => $variables});
		$anvil->Alert->register({alert_level => "warning", message => "scan_drbd_message_0001", variables => $variables, set_by => $THIS_FILE, sort_position => $anvil->data->{'scan-drbd'}{alert_sort}++});
		
		my $query = "
INSERT INTO 
    scan_drbd
(
    scan_drbd_uuid, 
    scan_drbd_host_uuid, 
    scan_drbd_common_xml, 
    scan_drbd_flush_disk, 
    scan_drbd_flush_md, 
    scan_drbd_timeout, 
    scan_drbd_total_sync_speed, 
    modified_date
) VALUES (
    ".$anvil->Database->quote($scan_drbd_uuid).", 
    ".$anvil->Database->quote($anvil->Get->host_uuid).", 
    ".$anvil->Database->quote($new_scan_drbd_common_xml).", 
    ".$anvil->Database->quote($new_scan_drbd_flush_disk).", 
    ".$anvil->Database->quote($new_scan_drbd_flush_md).", 
    ".$anvil->Database->quote($new_scan_drbd_timeout).", 
    ".$anvil->Database->quote($new_scan_drbd_total_sync_speed).", 
    ".$anvil->Database->quote($anvil->data->{sys}{database}{timestamp})."
);";
		# Now record the query in the array
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { query => $query }});
		$anvil->Database->write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

sub find_changes
{
	my ($anvil) = @_;
	
	#print Dumper $anvil->data->{new};
	my $new_scan_drbd_common_xml       = $anvil->data->{new}{scan_drbd}{scan_drbd_common_xml};
	my $new_scan_drbd_flush_disk       = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk};
	my $new_scan_drbd_flush_md         = $anvil->data->{new}{scan_drbd}{scan_drbd_flush_md};
	my $new_scan_drbd_timeout          = $anvil->data->{new}{scan_drbd}{scan_drbd_timeout};
	my $new_scan_drbd_total_sync_speed = $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed};
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
		"s1:new_scan_drbd_flush_disk"       => $new_scan_drbd_flush_disk, 
		"s2:new_scan_drbd_flush_md"         => $new_scan_drbd_flush_md, 
		"s3:new_scan_drbd_timeout"          => $new_scan_drbd_timeout, 
		"s4:new_scan_drbd_total_sync_speed" => $new_scan_drbd_total_sync_speed." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_total_sync_speed})."/s)", 
		"s5:new_scan_drbd_common_xml"       => $new_scan_drbd_common_xml, 
	}});
	
	process_scan_drbd($anvil);
	
	foreach my $resource (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}})
	{
		my $scan_drbd_resource_uuid    = $anvil->data->{new}{resource}{$resource}{scan_drbd_resource_uuid};
		my $scan_drbd_resource_name    = $resource; 
		my $new_scan_drbd_resource_up  = $anvil->data->{new}{resource}{$resource}{up};
		my $new_scan_drbd_resource_xml = $anvil->data->{new}{resource}{$resource}{xml};
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
			"s1:scan_drbd_resource_uuid"    => $scan_drbd_resource_uuid, 
			"s2:scan_drbd_resource_name"    => $new_scan_drbd_flush_disk, 
			"s3:new_scan_drbd_resource_up"  => $new_scan_drbd_flush_md, 
			"s4:new_scan_drbd_resource_xml" => $new_scan_drbd_resource_xml, 
		}});

		foreach my $volume (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{volume}})
		{
			my $scan_drbd_volume_number           = $volume;
			my $new_scan_drbd_volume_device_path  = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_path};
			my $new_scan_drbd_volume_device_minor = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_minor};
			my $new_scan_drbd_volume_size         = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{size};
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
				"s1:scan_drbd_volume_number"           => $scan_drbd_volume_number, 
				"s2:new_scan_drbd_volume_device_path"  => $new_scan_drbd_volume_device_path, 
				"s3:new_scan_drbd_volume_device_minor" => $new_scan_drbd_volume_device_minor, 
				"s4:new_scan_drbd_volume_size"         => $new_scan_drbd_volume_size." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_volume_size}).")",
			}});
		}
		
		foreach my $peer (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{peer}})
		{
			# These are common across all volumes
			my $scan_drbd_peer_host_name      = $peer;
			my $new_scan_drbd_peer_ip_address = $anvil->data->{new}{resource}{$resource}{peer}{$peer}{peer_ip_address};
			my $new_scan_drbd_peer_tcp_port   = $anvil->data->{new}{resource}{$resource}{peer}{$peer}{tcp_port};
			my $new_scan_drbd_peer_protocol   = $anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol};
			my $new_scan_drbd_peer_fencing    = $anvil->data->{new}{resource}{$resource}{peer}{$peer}{fencing};
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
				"s1:scan_drbd_peer_host_name"      => $scan_drbd_peer_host_name, 
				"s2:new_scan_drbd_peer_ip_address" => $new_scan_drbd_peer_ip_address, 
				"s3:new_scan_drbd_peer_tcp_port"   => $new_scan_drbd_peer_tcp_port, 
				"s4:new_scan_drbd_peer_protocol"   => $new_scan_drbd_peer_protocol,
				"s5:new_scan_drbd_peer_fencing"    => $new_scan_drbd_peer_fencing,
			}});
			
			foreach my $volume (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{volume}})
			{
				### NOTE: Volume needs to be volume_uuid by this point
				### NOTE: So, if we're a node and the peer is Sync'ing from DR, we'll see the
				###       OOS drop and can calculate the % sync change, but we don't see the 
				###       ETA. Also, it appears to be random which peer a node decides to 
				###       sync from. So what we'll need to do when generating the JSON for 
				###       the UI is to see which peers are SyncSource and SyncTarget and pull
				###       the ETA from them.
				my $new_scan_drbd_peer_connection_state       = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{connection_state};
				my $new_scan_drbd_peer_local_disk_state       = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_disk_state};
				my $new_scan_drbd_peer_disk_state             = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_disk_state};
				my $new_scan_drbd_peer_local_role             = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_role};
				my $new_scan_drbd_peer_role                   = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_role};
				my $new_scan_drbd_peer_out_of_sync_size       = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{out_of_sync_size};
				my $new_scan_drbd_peer_replication_speed      = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed};
				my $new_scan_drbd_peer_estimated_time_to_sync = $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{estimated_time_to_sync};
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => {
					"s1:volume"                                    => $volume, 
					"s2:new_scan_drbd_peer_connection_state"       => $new_scan_drbd_peer_connection_state, 
					"s3:new_scan_drbd_peer_local_disk_state"       => $new_scan_drbd_peer_local_disk_state, 
					"s4:new_scan_drbd_peer_disk_state"             => $new_scan_drbd_peer_disk_state, 
					"s5:new_scan_drbd_peer_local_role"             => $new_scan_drbd_peer_local_role, 
					"s6:new_scan_drbd_peer_role"                   => $new_scan_drbd_peer_role, 
					"s7:new_scan_drbd_peer_out_of_sync_size"       => $new_scan_drbd_peer_out_of_sync_size." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_peer_out_of_sync_size}).")", 
					"s8:new_scan_drbd_peer_replication_speed"      => $new_scan_drbd_peer_replication_speed." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $new_scan_drbd_peer_replication_speed})."/s)", 
					"s9:new_scan_drbd_peer_estimated_time_to_sync" => $new_scan_drbd_peer_estimated_time_to_sync." (".$anvil->Convert->time({'time' => $new_scan_drbd_peer_estimated_time_to_sync, long => 1, translate => 1}).")", 
				}});
			}
		}
	}
	
	return(0);
}

sub gather_data
{
	my ($anvil) = @_;
	
	if ((not -e $anvil->data->{path}{exe}{drbdadm}) or ($anvil->Get->host_type eq "striker"))
	{
		# DRBD isn't installed or this is a striker node.
		return(0);
	}
	
	# Parse drbdadm
	my ($drbd_xml, $return_code) = $anvil->System->call({shell_call => $anvil->data->{path}{exe}{drbdadm}." dump-xml"});
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { drbd_xml => $drbd_xml, return_code => $return_code }});
	if ($return_code)
	{
		# Failed to dump the XML.
		$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 1, key => "scan_drbd_error_0002", variables => { return_code => $return_code }});
		return(0);
	}
	else
	{
		local $@;
		my $dom = eval { XML::LibXML->load_xml(string => $drbd_xml); };
		if ($@)
		{
			$anvil->Log->entry({source => $THIS_FILE, line => __LINE__, level => 1, key => "scan_drbd_error_0003", variables => { 
				xml   => $drbd_xml,
				error => $@,
			}});
			return(0);
		}
		else
		{
			# Successful parse!
			### TODO: Might be best to config these default values by calling/parsing 
			###       'drbdsetup show <resource> --show-defaults'.
			$anvil->data->{new}{scan_drbd}{scan_drbd_common_xml}       = $drbd_xml;
			$anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk}       = 1;
			$anvil->data->{new}{scan_drbd}{scan_drbd_flush_md}         = 1;
			$anvil->data->{new}{scan_drbd}{scan_drbd_timeout}          = 6;		# Default is '60', 6 seconds
			$anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed} = 0;
			
			foreach my $name ($dom->findnodes('/config/common/section'))
			{
				my $section = $name->{name};
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { section => $section }});
				foreach my $option_name ($name->findnodes('./option'))
				{
					my $variable = $option_name->{name};
					my $value    = $option_name->{value};
					$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
						's1:variable' => $variable, 
						's2:value'    => $value,
					}});

					if ($section eq "net")
					{
						if ($variable eq "timeout")
						{
							$value /= 10;
							$anvil->data->{new}{scan_drbd}{scan_drbd_timeout} = ($value / 10);
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								"new::scan_drbd::scan_drbd_timeout" => $anvil->data->{new}{scan_drbd}{scan_drbd_timeout}, 
							}});
						}
					}
					if ($section eq "disk")
					{
						if ($variable eq "disk-flushes")
						{
							$anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk} = $value eq "no" ? 0 : 1;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								"new::scan_drbd::scan_drbd_flush_disk" => $anvil->data->{new}{scan_drbd}{scan_drbd_flush_disk}, 
							}});
						}
						if ($variable eq "md-flushes")
						{
							$anvil->data->{new}{scan_drbd}{scan_drbd_flush_md} = $value eq "no" ? 0 : 1;
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								"new::scan_drbd::scan_drbd_flush_md" => $anvil->data->{new}{scan_drbd}{scan_drbd_flush_md}, 
							}});
						}
					}
				}
			}
			
			foreach my $name ($dom->findnodes('/config/resource'))
			{
				my $resource  =  $name->{name};
				my $conf_file =  $name->{'conf-file-line'};
				   $conf_file =~ s/:\d+$//;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
					's1:resource'  => $resource, 
					's2:conf_file' => $conf_file,
				}});
				
				$anvil->data->{new}{resource}{$resource}{up}  = 0;
				$anvil->data->{new}{resource}{$resource}{xml} = $name->toString;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
					"new::resource::${resource}::xml" => $anvil->data->{new}{resource}{$resource}{xml},
				}});
				
				# See if there's a scan_drbd_resource_uuid in the config file.
				my $scan_drbd_resource_uuid = $anvil->DRBD->resource_uuid({
					debug         => 2,
					resource      => $resource,
					resource_file => $conf_file, 
				});
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { scan_drbd_resource_uuid => $scan_drbd_resource_uuid }});
				
				$anvil->data->{new}{resource}{$resource}{scan_drbd_resource_uuid} = $scan_drbd_resource_uuid eq "!!error!!" ? "" : $scan_drbd_resource_uuid;
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { 
					"new::resource::${resource}::scan_drbd_resource_uuid" => $anvil->data->{new}{resource}{$resource}{scan_drbd_resource_uuid},
				}});
				
				foreach my $host ($name->findnodes('./host'))
				{
					my $this_host_name = $host->{name};
					$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { this_host_name => $this_host_name }});
					
					next if (($this_host_name ne $anvil->Get->host_name) && ($this_host_name ne $anvil->Get->short_host_name));
					
					foreach my $volume_vnr ($host->findnodes('./volume'))
					{
						my $volume    = $volume_vnr->{vnr};
						my $meta_disk = $volume_vnr->findvalue('./meta-disk');
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							's1:volume'    => $volume,
							's2:meta_disk' => $meta_disk, 
						}});
						
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_path}    = $volume_vnr->findvalue('./device');
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_minor}   = $volume_vnr->findvalue('./device/@minor');
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{size}           = 0;
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"s1:new::resource::${resource}::volume::${volume}::device_path"  => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_path},
							"s2:new::resource::${resource}::volume::${volume}::device_minor" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_minor},
						}});
					}
				}
				
				foreach my $connection ($name->findnodes('./connection'))
				{
					my $peer = "";
					foreach my $host ($connection->findnodes('./host'))
					{
						my $this_host_name = $host->{name};
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { this_host_name => $this_host_name }});
						
						next if (($this_host_name eq $anvil->Get->host_name) or ($this_host_name eq $anvil->Get->short_host_name));
						
						$peer                                                                  = $this_host_name;
						$anvil->data->{new}{resource}{$resource}{peer}{$peer}{peer_ip_address} = $host->findvalue('./address'); 
						$anvil->data->{new}{resource}{$resource}{peer}{$peer}{tcp_port}        = $host->findvalue('./address/@port');; 
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"s1:new::resource::${resource}::peer::${peer}::peer_ip_address" => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{peer_ip_address},
							"s2:new::resource::${resource}::peer::${peer}::tcp_port"        => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{tcp_port},
						}});
						
						if (not exists $anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol})
						{
							$anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol}        = "unknown";
							$anvil->data->{new}{resource}{$resource}{peer}{$peer}{fencing}         = "unknown";
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								"s1:new::resource::${resource}::peer::${peer}::protocol"        => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol},
								"s2:new::resource::${resource}::peer::${peer}::fencing"         => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{fencing},
							}});
						}
						
						foreach my $volume (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{volume}})
						{
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{connection_state}       = "disconnected";
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_disk_state}       = "down"; 
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_disk_state}        = "unknown"; 
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_role}             = "down"; 
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_role}              = "unknown"; 
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{out_of_sync_size}       = -1; 
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed}      = 0;
							$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{estimated_time_to_sync} = 0; 
						}
					}
					
					foreach my $name ($connection->findnodes('./section'))
					{
						my $section = $name->{name};
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { section => $section }});
						
						foreach my $option_name ($name->findnodes('./option'))
						{
							my $variable = $option_name->{name};
							my $value    = $option_name->{value};
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								's1:variable' => $variable, 
								's2:value'    => $value,
							}});

							if ($section eq "net")
							{
								if ($variable eq "protocol")
								{
									$anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol} = $value;
									$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
										"new::resource::${resource}::peer::${peer}::protocol" => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{protocol},
									}});
								}
								if ($variable eq "fencing")
								{
									$anvil->data->{new}{resource}{$resource}{peer}{$peer}{fencing} = $value;
									$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
										"new::resource::${resource}::peer::${peer}::fencing" => $anvil->data->{new}{resource}{$resource}{peer}{$peer}{fencing},
									}});
								}
							}
						}
					}
				}
			}
		}
	}
	
	local(*DIRECTORY);
	opendir(DIRECTORY, $anvil->data->{'scan-drbd'}{resource_status});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		my $full_path = $anvil->data->{'scan-drbd'}{resource_status}."/".$file;
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { full_path => $full_path }});
		if (-d $full_path)
		{
			my $resource                                    = $file;
			   $anvil->data->{new}{resource}{$resource}{up} = 1;
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
				"new::resource::${resource}::up" => $anvil->data->{new}{resource}{$resource}{up},
			}});
		}
	}
	closedir(DIRECTORY);

	#print "Sync progress:\n";
	#print "  ".sprintf("%-${longest_resource}s", "Res")."    ".sprintf("%-${longest_connection}s", "To")."    Vol\n";
	foreach my $resource (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}})
	{
		$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
			"new::resource::${resource}::up" => $anvil->data->{new}{resource}{$resource}{up},
		}});
		
		# If the resource isn't up, there's won't be a proc file to read.
		next if not $anvil->data->{new}{resource}{$resource}{up};
		
		foreach my $volume (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{volume}})
		{
			$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { volume => $volume }});
			
			foreach my $peer (sort {$a cmp $b} keys %{$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}})
			{
				my $proc_file = $anvil->data->{'scan-drbd'}{resource_status}."/".$resource."/connections/".$peer."/".$volume."/proc_drbd";
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { proc_file => $proc_file }});
				
				my $file_body = $anvil->Storage->read_file({file => $proc_file});
				my $progress  = "";
				$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { file_body => $file_body }});
				foreach my $line (split/\n/, $file_body)
				{
					$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 3, list => { line => $line }});

					if ($line =~ /cs:(.*?) /)
					{
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{connection_state} = lc($1);
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"new::resource::${resource}::volume::${volume}::peer::${peer}::connection_state" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{connection_state},
						}});
					}
					if ($line =~ /ro:(.*?)\/(.*?) /)
					{
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_role} = lc($1);
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_role}  = lc($2);
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"new::resource::${resource}::volume::${volume}::peer::${peer}::local_role" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_role},
							"new::resource::${resource}::volume::${volume}::peer::${peer}::peer_role"  => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_role},
						}});
						
						# If the peer is secondary, read the device size.
						if ($anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_role} eq "secondary")
						{
							# Get the size of the DRBD device.
							my ($size, $return_code) = $anvil->System->call({secure => 1, shell_call => $anvil->data->{path}{exe}{blockdev}." --getsize64 /dev/drbd".$anvil->data->{new}{resource}{$resource}{volume}{$volume}{device_minor}});
							$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
								size        => $size, 
								return_code => $return_code,
							}});
							if (not $return_code)
							{
								$anvil->data->{new}{resource}{$resource}{volume}{$volume}{size} = $size;
								$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
									"new::resource::${resource}::volume::${volume}::size" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{size}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{size}}).")",
								}});
							}
						}
					}
					if ($line =~ /ds:(.*?)\/(.*?) /)
					{
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_disk_state} = lc($1);
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_disk_state}  = lc($2); 
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"new::resource::${resource}::volume::${volume}::peer::${peer}::local_disk_state" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{local_disk_state},
							"new::resource::${resource}::volume::${volume}::peer::${peer}::peer_disk_state"  => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{peer_disk_state},
						}});
					}
					if ($line =~ /oos:(\d+)/)
					{
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{out_of_sync_size} = $1 * 1024;
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"new::resource::${resource}::volume::${volume}::peer::${peer}::out_of_sync_size" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{out_of_sync_size}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{out_of_sync_size}}).")",
						}});
					}
=cut
 0: cs:Established ro:Secondary/Secondary ds:Inconsistent/Inconsistent C r-----
    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:[0;0] ua:0 ap:[0;0] ep:1 wo:1 oos:0
	resync: used:0/61 hits:0 misses:0 starving:0 locked:0 changed:0
	act_log: used:0/1237 hits:0 misses:0 starving:0 locked:0 changed:0
	blocked on activity log: 0/0/0

 0: cs:SyncTarget ro:Secondary/Primary ds:Inconsistent/UpToDate C r-----
    ns:0 nr:648960 dw:648728 dr:0 al:0 bm:0 lo:4 pe:[0;1] ua:4 ap:[0;0] ep:1 wo:1 oos:20321476
	[>....................] sync'ed:  3.2% (19844/20476)M
	finish: 0:03:39 speed: 92,672 (92,936 -- 92,672) want: 2,880 K/sec
	  3% sector pos: 1298032/41940408
	resync: used:1/61 hits:31926 misses:10 starving:0 locked:0 changed:5
	act_log: used:0/1237 hits:0 misses:0 starving:0 locked:0 changed:0
	blocked on activity log: 0/0/0
=cut					
					if ($line =~ /sync'ed:\s+(\d.*\%)/)
					{
						$progress .= $1;
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { progress => $progress }});
					}
					if ($line =~ /speed: (.*?) \(/)
					{
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed} =  $1;
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed} =~ s/,//g;
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed} *= 1024;
						$anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}                                += $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed};
						
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"s1:new::resource::${resource}::volume::${volume}::peer::${peer}::replication_speed" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{replication_speed}}).")",
							"s2:new::scan_drbd::scan_drbd_total_sync_speed"                                      => $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}}).")",
						}});
						   
					}
					if ($line =~ /finish: (\d+):(\d+):(\d+) /)
					{
						my $hours     = $1;
						my $minutes   = $2;
						my $seconds   = $3;
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							's1:hours'     => $hours,
							's2:minutes'   => $minutes,
							's3:seconds'   => $seconds,
						}});
						
						$anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{estimated_time_to_sync} = (($hours * 3600) + ($minutes * 60) + $seconds);
						$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
							"new::resource::${resource}::volume::${volume}::peer::${peer}::estimated_time_to_sync" => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{estimated_time_to_sync}." (".$anvil->Convert->time({'time' => $anvil->data->{new}{resource}{$resource}{volume}{$volume}{peer}{$peer}{estimated_time_to_sync}, long => 1, translate => 1}).")",
						}});
					}
				}
			}
		}
	}
	$anvil->Log->variables({source => $THIS_FILE, line => __LINE__, level => 2, list => { 
		"s2:new::scan_drbd::scan_drbd_total_sync_speed" => $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}." (".$anvil->Convert->bytes_to_human_readable({'bytes' => $anvil->data->{new}{scan_drbd}{scan_drbd_total_sync_speed}}).")",
	}});

	return(1);
}
